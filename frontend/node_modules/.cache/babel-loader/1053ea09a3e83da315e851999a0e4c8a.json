{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"../node\"),\n    convertNodesIntoNode = _require.convertNodesIntoNode;\n\nvar ChildNodeImpl = /*#__PURE__*/function () {\n  function ChildNodeImpl() {\n    _classCallCheck(this, ChildNodeImpl);\n  }\n\n  _createClass(ChildNodeImpl, [{\n    key: \"remove\",\n    value: function remove() {\n      if (!this.parentNode) {\n        return;\n      }\n\n      this.parentNode.removeChild(this);\n    }\n  }, {\n    key: \"after\",\n    value: function after() {\n      var parent = this.parentNode;\n\n      if (parent) {\n        var viableNextSibling = this.nextSibling;\n\n        for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n          nodes[_key] = arguments[_key];\n        }\n\n        var idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n\n        while (idx !== -1) {\n          viableNextSibling = viableNextSibling.nextSibling;\n\n          if (!viableNextSibling) {\n            break;\n          }\n\n          idx = nodes.indexOf(viableNextSibling);\n        }\n\n        parent.insertBefore(convertNodesIntoNode(this._ownerDocument, nodes), viableNextSibling);\n      }\n    }\n  }, {\n    key: \"before\",\n    value: function before() {\n      var parent = this.parentNode;\n\n      if (parent) {\n        var viablePreviousSibling = this.previousSibling;\n\n        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          nodes[_key2] = arguments[_key2];\n        }\n\n        var idx = viablePreviousSibling ? nodes.indexOf(viablePreviousSibling) : -1;\n\n        while (idx !== -1) {\n          viablePreviousSibling = viablePreviousSibling.previousSibling;\n\n          if (!viablePreviousSibling) {\n            break;\n          }\n\n          idx = nodes.indexOf(viablePreviousSibling);\n        }\n\n        parent.insertBefore(convertNodesIntoNode(this._ownerDocument, nodes), viablePreviousSibling ? viablePreviousSibling.nextSibling : parent.firstChild);\n      }\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith() {\n      var parent = this.parentNode;\n\n      if (parent) {\n        var viableNextSibling = this.nextSibling;\n\n        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          nodes[_key3] = arguments[_key3];\n        }\n\n        var idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n\n        while (idx !== -1) {\n          viableNextSibling = viableNextSibling.nextSibling;\n\n          if (!viableNextSibling) {\n            break;\n          }\n\n          idx = nodes.indexOf(viableNextSibling);\n        }\n\n        var node = convertNodesIntoNode(this._ownerDocument, nodes);\n\n        if (this.parentNode === parent) {\n          parent.replaceChild(node, this);\n        } else {\n          parent.insertBefore(node, viableNextSibling);\n        }\n      }\n    }\n  }]);\n\n  return ChildNodeImpl;\n}();\n\nmodule.exports = {\n  implementation: ChildNodeImpl\n};","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/nodes/ChildNode-impl.js"],"names":["require","convertNodesIntoNode","ChildNodeImpl","parentNode","removeChild","parent","viableNextSibling","nextSibling","nodes","idx","indexOf","insertBefore","_ownerDocument","viablePreviousSibling","previousSibling","firstChild","node","replaceChild","module","exports","implementation"],"mappings":"AAAA;;;;;;eAEiCA,OAAO,CAAC,SAAD,C;IAAhCC,oB,YAAAA,oB;;IAEFC,a;;;;;;;6BACK;AACP,UAAI,CAAC,KAAKC,UAAV,EAAsB;AACpB;AACD;;AAED,WAAKA,UAAL,CAAgBC,WAAhB,CAA4B,IAA5B;AACD;;;4BAEe;AACd,UAAMC,MAAM,GAAG,KAAKF,UAApB;;AACA,UAAIE,MAAJ,EAAY;AACV,YAAIC,iBAAiB,GAAG,KAAKC,WAA7B;;AADU,0CAFLC,KAEK;AAFLA,UAAAA,KAEK;AAAA;;AAEV,YAAIC,GAAG,GAAGH,iBAAiB,GAAGE,KAAK,CAACE,OAAN,CAAcJ,iBAAd,CAAH,GAAsC,CAAC,CAAlE;;AAEA,eAAOG,GAAG,KAAK,CAAC,CAAhB,EAAmB;AACjBH,UAAAA,iBAAiB,GAAGA,iBAAiB,CAACC,WAAtC;;AACA,cAAI,CAACD,iBAAL,EAAwB;AACtB;AACD;;AACDG,UAAAA,GAAG,GAAGD,KAAK,CAACE,OAAN,CAAcJ,iBAAd,CAAN;AACD;;AACDD,QAAAA,MAAM,CAACM,YAAP,CAAoBV,oBAAoB,CAAC,KAAKW,cAAN,EAAsBJ,KAAtB,CAAxC,EAAsEF,iBAAtE;AACD;AACF;;;6BAEgB;AACf,UAAMD,MAAM,GAAG,KAAKF,UAApB;;AACA,UAAIE,MAAJ,EAAY;AACV,YAAIQ,qBAAqB,GAAG,KAAKC,eAAjC;;AADU,2CAFJN,KAEI;AAFJA,UAAAA,KAEI;AAAA;;AAEV,YAAIC,GAAG,GAAGI,qBAAqB,GAAGL,KAAK,CAACE,OAAN,CAAcG,qBAAd,CAAH,GAA0C,CAAC,CAA1E;;AAEA,eAAOJ,GAAG,KAAK,CAAC,CAAhB,EAAmB;AACjBI,UAAAA,qBAAqB,GAAGA,qBAAqB,CAACC,eAA9C;;AACA,cAAI,CAACD,qBAAL,EAA4B;AAC1B;AACD;;AACDJ,UAAAA,GAAG,GAAGD,KAAK,CAACE,OAAN,CAAcG,qBAAd,CAAN;AACD;;AAEDR,QAAAA,MAAM,CAACM,YAAP,CACEV,oBAAoB,CAAC,KAAKW,cAAN,EAAsBJ,KAAtB,CADtB,EAEEK,qBAAqB,GAAGA,qBAAqB,CAACN,WAAzB,GAAuCF,MAAM,CAACU,UAFrE;AAID;AACF;;;kCAEqB;AACpB,UAAMV,MAAM,GAAG,KAAKF,UAApB;;AACA,UAAIE,MAAJ,EAAY;AACV,YAAIC,iBAAiB,GAAG,KAAKC,WAA7B;;AADU,2CAFCC,KAED;AAFCA,UAAAA,KAED;AAAA;;AAEV,YAAIC,GAAG,GAAGH,iBAAiB,GAAGE,KAAK,CAACE,OAAN,CAAcJ,iBAAd,CAAH,GAAsC,CAAC,CAAlE;;AAEA,eAAOG,GAAG,KAAK,CAAC,CAAhB,EAAmB;AACjBH,UAAAA,iBAAiB,GAAGA,iBAAiB,CAACC,WAAtC;;AACA,cAAI,CAACD,iBAAL,EAAwB;AACtB;AACD;;AACDG,UAAAA,GAAG,GAAGD,KAAK,CAACE,OAAN,CAAcJ,iBAAd,CAAN;AACD;;AAED,YAAMU,IAAI,GAAGf,oBAAoB,CAAC,KAAKW,cAAN,EAAsBJ,KAAtB,CAAjC;;AAEA,YAAI,KAAKL,UAAL,KAAoBE,MAAxB,EAAgC;AAC9BA,UAAAA,MAAM,CAACY,YAAP,CAAoBD,IAApB,EAA0B,IAA1B;AACD,SAFD,MAEO;AACLX,UAAAA,MAAM,CAACM,YAAP,CAAoBK,IAApB,EAA0BV,iBAA1B;AACD;AACF;AACF;;;;;;AAGHY,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,cAAc,EAAElB;AADD,CAAjB","sourcesContent":["\"use strict\";\n\nconst { convertNodesIntoNode } = require(\"../node\");\n\nclass ChildNodeImpl {\n  remove() {\n    if (!this.parentNode) {\n      return;\n    }\n\n    this.parentNode.removeChild(this);\n  }\n\n  after(...nodes) {\n    const parent = this.parentNode;\n    if (parent) {\n      let viableNextSibling = this.nextSibling;\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n\n      while (idx !== -1) {\n        viableNextSibling = viableNextSibling.nextSibling;\n        if (!viableNextSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viableNextSibling);\n      }\n      parent.insertBefore(convertNodesIntoNode(this._ownerDocument, nodes), viableNextSibling);\n    }\n  }\n\n  before(...nodes) {\n    const parent = this.parentNode;\n    if (parent) {\n      let viablePreviousSibling = this.previousSibling;\n      let idx = viablePreviousSibling ? nodes.indexOf(viablePreviousSibling) : -1;\n\n      while (idx !== -1) {\n        viablePreviousSibling = viablePreviousSibling.previousSibling;\n        if (!viablePreviousSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viablePreviousSibling);\n      }\n\n      parent.insertBefore(\n        convertNodesIntoNode(this._ownerDocument, nodes),\n        viablePreviousSibling ? viablePreviousSibling.nextSibling : parent.firstChild\n      );\n    }\n  }\n\n  replaceWith(...nodes) {\n    const parent = this.parentNode;\n    if (parent) {\n      let viableNextSibling = this.nextSibling;\n      let idx = viableNextSibling ? nodes.indexOf(viableNextSibling) : -1;\n\n      while (idx !== -1) {\n        viableNextSibling = viableNextSibling.nextSibling;\n        if (!viableNextSibling) {\n          break;\n        }\n        idx = nodes.indexOf(viableNextSibling);\n      }\n\n      const node = convertNodesIntoNode(this._ownerDocument, nodes);\n\n      if (this.parentNode === parent) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(node, viableNextSibling);\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: ChildNodeImpl\n};\n"]},"metadata":{},"sourceType":"script"}