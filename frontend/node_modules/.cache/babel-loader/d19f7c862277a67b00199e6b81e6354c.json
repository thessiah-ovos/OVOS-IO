{"ast":null,"code":"\"use strict\";\n\nvar MIMEType = require(\"whatwg-mimetype\");\n\nvar parseDataURL = require(\"data-urls\");\n\nvar sniffHTMLEncoding = require(\"html-encoding-sniffer\");\n\nvar whatwgEncoding = require(\"whatwg-encoding\");\n\nvar fs = require(\"fs\");\n\nvar request = require(\"request\");\n\nvar _require = require(\"../living/helpers/document-base-url\"),\n    documentBaseURLSerialized = _require.documentBaseURLSerialized;\n\nvar NODE_TYPE = require(\"../living/node-type\");\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\n\n\nvar URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\n\nvar IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = function loadCallback() {// do nothing\n    };\n  }\n\n  return function (err, data, response) {\n    var ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n        var error = new Error(\"Could not load \".concat(element.localName, \": \\\"\").concat(resourceUrl, \"\\\"\"));\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, _ref, callback) {\n  var defaultEncoding = _ref.defaultEncoding,\n      detectMetaCharset = _ref.detectMetaCharset;\n  var readableStream = fs.createReadStream(filePath);\n  var data = Buffer.alloc(0);\n  readableStream.on(\"error\", callback);\n  readableStream.on(\"data\", function (chunk) {\n    data = Buffer.concat([data, chunk]);\n  });\n  readableStream.on(\"end\", function () {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      var encoding = detectMetaCharset ? sniffHTMLEncoding(data, {\n        defaultEncoding: defaultEncoding\n      }) : whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      var decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": \"text/plain;charset=\" + encoding\n        }\n      });\n    } else {\n      callback(null, data);\n    }\n  });\n  return {\n    abort: function abort() {\n      readableStream.destroy();\n      var error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nfunction readDataURL(dataURL, _ref2, callback) {\n  var defaultEncoding = _ref2.defaultEncoding,\n      detectMetaCharset = _ref2.detectMetaCharset;\n\n  try {\n    var parsed = parseDataURL(dataURL); // If default encoding does not exist, pass on binary data.\n\n    if (defaultEncoding) {\n      var sniffOptions = {\n        transportLayerEncodingLabel: parsed.mimeType.parameters.get(\"charset\"),\n        defaultEncoding: defaultEncoding\n      };\n      var encoding = detectMetaCharset ? sniffHTMLEncoding(parsed.body, sniffOptions) : whatwgEncoding.getBOMEncoding(parsed.body) || whatwgEncoding.labelToName(parsed.mimeType.parameters.get(\"charset\")) || defaultEncoding;\n      var decoded = whatwgEncoding.decode(parsed.body, encoding);\n      parsed.mimeType.parameters.set(\"charset\", encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    } else {\n      callback(null, parsed.body, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n\n  return null;\n} // NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\n\n\nexports.wrapCookieJarForRequest = function (cookieJar) {\n  var jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataURL(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n\n  var filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  var document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    var loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return function () {// do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  var requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n\n  Object.assign(requestOptions.headers, options.headers);\n  var defaultEncoding = options.defaultEncoding,\n      detectMetaCharset = options.detectMetaCharset;\n  var req = request(url, requestOptions, function (error, response, bufferData) {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        var contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        var sniffOptions = {\n          transportLayerEncodingLabel: contentType.parameters.get(\"charset\"),\n          defaultEncoding: defaultEncoding\n        };\n        var encoding = detectMetaCharset ? sniffHTMLEncoding(bufferData, sniffOptions) : whatwgEncoding.getBOMEncoding(bufferData) || whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) || defaultEncoding;\n        var decoded = whatwgEncoding.decode(bufferData, encoding);\n        contentType.parameters.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort: function abort() {\n      req.abort();\n      var error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  var document = element._ownerDocument;\n  var documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  var urlObj = URL.parse(urlString);\n  var enqueued = exports.enqueue(element, urlString, callback);\n  var customLoader = document._customResourceLoader;\n  var requestManager = document._requestManager;\n  var cookieJar = document._cookieJar;\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n  var req = null;\n\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    } // do not trigger if the window is closed\n\n\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n\n  if (typeof customLoader === \"function\") {\n    req = customLoader({\n      element: element,\n      url: urlObj,\n      cookie: cookieJar.getCookieStringSync(urlObj, {\n        http: true\n      }),\n      baseUrl: documentBaseURLSerialized(document),\n      defaultFetch: function defaultFetch(fetchCallback) {\n        return fetch(urlObj, options, fetchCallback);\n      }\n    }, wrappedEnqueued);\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/browser/resource-loader.js"],"names":["MIMEType","require","parseDataURL","sniffHTMLEncoding","whatwgEncoding","fs","request","documentBaseURLSerialized","NODE_TYPE","URL","IS_BROWSER","Object","prototype","toString","call","process","createResourceLoadHandler","element","resourceUrl","document","loadCallback","undefined","err","data","response","ev","createEvent","initEvent","e","isAbortError","error","dispatchEvent","Error","localName","detail","type","_defaultView","_virtualConsole","emit","exports","readFile","filePath","callback","defaultEncoding","detectMetaCharset","readableStream","createReadStream","Buffer","alloc","on","chunk","concat","encoding","getBOMEncoding","decoded","decode","headers","abort","destroy","readDataURL","dataURL","parsed","sniffOptions","transportLayerEncodingLabel","mimeType","parameters","get","body","labelToName","set","wrapCookieJarForRequest","cookieJar","jarWrapper","jar","_jar","fetch","urlObj","options","protocol","href","hostname","download","pathname","replace","enqueue","nodeType","DOCUMENT_NODE","_ownerDocument","_queue","loadHandler","push","url","requestOptions","pool","agent","agentOptions","agentClass","strictSSL","gzip","userAgent","Accept","accept","referrer","referer","proxy","assign","req","bufferData","contentType","parse","load","urlString","documentImpl","implementation","_hasFeature","tagName","toLowerCase","enqueued","customLoader","_customResourceLoader","requestManager","_requestManager","_cookieJar","_accept","_pool","_agentOptions","_strictSSL","_proxy","navigator","wrappedEnqueued","remove","defaultView","apply","arguments","cookie","getCookieStringSync","http","baseUrl","defaultFetch","fetchCallback","add"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\nconst parseDataURL = require(\"data-urls\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst fs = require(\"fs\");\nconst request = require(\"request\");\nconst { documentBaseURLSerialized } = require(\"../living/helpers/document-base-url\");\nconst NODE_TYPE = require(\"../living/node-type\");\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {\n      // do nothing\n    };\n  }\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n\n        const error = new Error(`Could not load ${element.localName}: \"${resourceUrl}\"`);\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, { defaultEncoding, detectMetaCharset }, callback) {\n  const readableStream = fs.createReadStream(filePath);\n\n  let data = Buffer.alloc(0);\n\n  readableStream.on(\"error\", callback);\n\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ?\n                       sniffHTMLEncoding(data, { defaultEncoding }) :\n                       whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, { headers: { \"content-type\": \"text/plain;charset=\" + encoding } });\n    } else {\n      callback(null, data);\n    }\n  });\n\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nfunction readDataURL(dataURL, { defaultEncoding, detectMetaCharset }, callback) {\n  try {\n    const parsed = parseDataURL(dataURL);\n    // If default encoding does not exist, pass on binary data.\n    if (defaultEncoding) {\n      const sniffOptions = {\n        transportLayerEncodingLabel: parsed.mimeType.parameters.get(\"charset\"),\n        defaultEncoding\n      };\n\n      const encoding = detectMetaCharset ?\n                       sniffHTMLEncoding(parsed.body, sniffOptions) :\n                       whatwgEncoding.getBOMEncoding(parsed.body) ||\n                        whatwgEncoding.labelToName(parsed.mimeType.parameters.get(\"charset\")) ||\n                        defaultEncoding;\n      const decoded = whatwgEncoding.decode(parsed.body, encoding);\n\n      parsed.mimeType.parameters.set(\"charset\", encoding);\n\n      callback(null, decoded, { headers: { \"content-type\": parsed.mimeType.toString() } });\n    } else {\n      callback(null, parsed.body, { headers: { \"content-type\": parsed.mimeType.toString() } });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n  return null;\n}\n\n// NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\nexports.wrapCookieJarForRequest = cookieJar => {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataURL(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n  const filePath = urlObj.pathname\n    .replace(/^file:\\/\\//, \"\")\n    .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n    .replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {\n    // do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n  Object.assign(requestOptions.headers, options.headers);\n\n  const { defaultEncoding, detectMetaCharset } = options;\n\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.parameters.get(\"charset\"),\n          defaultEncoding\n        };\n\n        const encoding = detectMetaCharset ?\n                         sniffHTMLEncoding(bufferData, sniffOptions) :\n                         whatwgEncoding.getBOMEncoding(bufferData) ||\n                           whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) ||\n                           defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n\n        contentType.parameters.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n\n  let req = null;\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    }\n    // do not trigger if the window is closed\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n  if (typeof customLoader === \"function\") {\n    req = customLoader(\n      {\n        element,\n        url: urlObj,\n        cookie: cookieJar.getCookieStringSync(urlObj, { http: true }),\n        baseUrl: documentBaseURLSerialized(document),\n        defaultFetch(fetchCallback) {\n          return fetch(urlObj, options, fetchCallback);\n        }\n      },\n      wrappedEnqueued\n    );\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}