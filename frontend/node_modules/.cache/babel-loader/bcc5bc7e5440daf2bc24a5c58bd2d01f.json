{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require(\"../helpers/selectors\"),\n    addNwsapi = _require.addNwsapi;\n\nvar _require2 = require(\"../helpers/namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar _require3 = require(\"../../utils\"),\n    mixin = _require3.mixin,\n    memoizeQuery = _require3.memoizeQuery;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar NodeImpl = require(\"./Node-impl\").implementation;\n\nvar ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nvar ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nvar attributes = require(\"../attributes\");\n\nvar namedPropertiesWindow = require(\"../named-properties-window\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require4 = require(\"../../browser/domtohtml\"),\n    domToHtml = _require4.domToHtml;\n\nvar _require5 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require5.domSymbolTree;\n\nvar DOMException = require(\"domexception\");\n\nvar DOMTokenList = require(\"../generated/DOMTokenList\");\n\nvar attrGenerated = require(\"../generated/Attr\");\n\nvar NamedNodeMap = require(\"../generated/NamedNodeMap\");\n\nvar validateNames = require(\"../helpers/validate-names\");\n\nvar _require6 = require(\"../helpers/strings\"),\n    asciiLowercase = _require6.asciiLowercase;\n\nvar _require7 = require(\"../node\"),\n    clone = _require7.clone,\n    listOfElementsWithQualifiedName = _require7.listOfElementsWithQualifiedName,\n    listOfElementsWithNamespaceAndLocalName = _require7.listOfElementsWithNamespaceAndLocalName,\n    listOfElementsWithClassNames = _require7.listOfElementsWithClassNames;\n\nvar NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nfunction clearChildNodes(node) {\n  for (var child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (node.nodeName === \"#document\") {\n    document._htmlToDom.appendToDocument(html, node);\n  } else {\n    document._htmlToDom.appendToNode(html, node);\n  }\n}\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      var elms = doc._ids[id];\n\n      for (var i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nvar ElementImpl = /*#__PURE__*/function (_NodeImpl) {\n  _inherits(ElementImpl, _NodeImpl);\n\n  var _super = _createSuper(ElementImpl);\n\n  function ElementImpl(args, privateData) {\n    var _this;\n\n    _classCallCheck(this, ElementImpl);\n\n    _this = _super.call(this, args, privateData);\n    _this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    _this.scrollTop = 0;\n    _this.scrollLeft = 0;\n    _this._namespaceURI = privateData.namespace || null;\n    _this._prefix = null;\n    _this._localName = privateData.localName;\n    _this._attributeList = []; // Used for caching.\n\n    _this._attributesByNameMap = new Map();\n    _this._attributes = NamedNodeMap.createImpl([], {\n      element: _assertThisInitialized(_this)\n    });\n    return _this;\n  }\n\n  _createClass(ElementImpl, [{\n    key: \"_attach\",\n    value: function _attach() {\n      namedPropertiesWindow.nodeAttachedToDocument(this);\n      var id = this.getAttribute(\"id\");\n\n      if (id) {\n        attachId(id, this, this._ownerDocument);\n      }\n\n      _get(_getPrototypeOf(ElementImpl.prototype), \"_attach\", this).call(this);\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      _get(_getPrototypeOf(ElementImpl.prototype), \"_detach\", this).call(this);\n\n      namedPropertiesWindow.nodeDetachedFromDocument(this);\n      var id = this.getAttribute(\"id\");\n\n      if (id) {\n        detachId(id, this, this._ownerDocument);\n      }\n    }\n  }, {\n    key: \"_attrModified\",\n    value: function _attrModified(name, value, oldValue) {\n      this._modified();\n\n      namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n      if (name === \"id\" && this._attached) {\n        var doc = this._ownerDocument;\n        detachId(oldValue, this, doc);\n        attachId(value, this, doc);\n      } // update classList\n\n\n      if (name === \"class\" && this._classList !== undefined) {\n        this._classList.attrModified();\n      }\n    }\n  }, {\n    key: \"hasAttributes\",\n    value: function hasAttributes() {\n      return attributes.hasAttributes(this);\n    }\n  }, {\n    key: \"getAttributeNames\",\n    value: function getAttributeNames() {\n      return attributes.attributeNames(this);\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      var attr = attributes.getAttributeByName(this, name);\n\n      if (!attr) {\n        return null;\n      }\n\n      return attr._value;\n    }\n  }, {\n    key: \"getAttributeNS\",\n    value: function getAttributeNS(namespace, localName) {\n      var attr = attributes.getAttributeByNameNS(this, namespace, localName);\n\n      if (!attr) {\n        return null;\n      }\n\n      return attr._value;\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      validateNames.name(name);\n\n      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        name = asciiLowercase(name);\n      }\n\n      var attribute = attributes.getAttributeByName(this, name);\n\n      if (attribute === null) {\n        var newAttr = attrGenerated.createImpl([], {\n          localName: name,\n          value: value\n        });\n        attributes.appendAttribute(this, newAttr);\n        return;\n      }\n\n      attributes.changeAttribute(this, attribute, value);\n    }\n  }, {\n    key: \"setAttributeNS\",\n    value: function setAttributeNS(namespace, name, value) {\n      var extracted = validateNames.validateAndExtract(namespace, name);\n      attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      attributes.removeAttributeByName(this, name);\n    }\n  }, {\n    key: \"removeAttributeNS\",\n    value: function removeAttributeNS(namespace, localName) {\n      attributes.removeAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        name = asciiLowercase(name);\n      }\n\n      return attributes.hasAttributeByName(this, name);\n    }\n  }, {\n    key: \"hasAttributeNS\",\n    value: function hasAttributeNS(namespace, localName) {\n      if (namespace === \"\") {\n        namespace = null;\n      }\n\n      return attributes.hasAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"getAttributeNode\",\n    value: function getAttributeNode(name) {\n      return attributes.getAttributeByName(this, name);\n    }\n  }, {\n    key: \"getAttributeNodeNS\",\n    value: function getAttributeNodeNS(namespace, localName) {\n      return attributes.getAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"setAttributeNode\",\n    value: function setAttributeNode(attr) {\n      return attributes.setAttribute(this, attr);\n    }\n  }, {\n    key: \"setAttributeNodeNS\",\n    value: function setAttributeNodeNS(attr) {\n      return attributes.setAttribute(this, attr);\n    }\n  }, {\n    key: \"removeAttributeNode\",\n    value: function removeAttributeNode(attr) {\n      if (!attributes.hasAttribute(this, attr)) {\n        throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n      }\n\n      attributes.removeAttribute(this, attr);\n      return attr;\n    }\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect() {\n      return {\n        bottom: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        width: 0\n      };\n    }\n  }, {\n    key: \"getClientRects\",\n    value: function getClientRects() {\n      return [];\n    }\n  }, {\n    key: \"insertAdjacentHTML\",\n    // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n    value: function insertAdjacentHTML(position, text) {\n      position = position.toLowerCase();\n      var context;\n\n      switch (position) {\n        case \"beforebegin\":\n        case \"afterend\":\n          {\n            context = this.parentNode;\n\n            if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n              throw new DOMException(\"Cannot insert HTML adjacent to \" + \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n            }\n\n            break;\n          }\n\n        case \"afterbegin\":\n        case \"beforeend\":\n          {\n            context = this;\n            break;\n          }\n\n        default:\n          {\n            throw new DOMException(\"Must provide one of \\\"beforebegin\\\", \\\"afterend\\\", \" + \"\\\"afterbegin\\\", or \\\"beforeend\\\".\", \"SyntaxError\");\n          }\n      } // TODO: use context for parsing instead of a <template>.\n\n\n      var fragment = this.ownerDocument.createElement(\"template\");\n      fragment.innerHTML = text;\n\n      switch (position) {\n        case \"beforebegin\":\n          {\n            this.parentNode.insertBefore(fragment.content, this);\n            break;\n          }\n\n        case \"afterbegin\":\n          {\n            this.insertBefore(fragment.content, this.firstChild);\n            break;\n          }\n\n        case \"beforeend\":\n          {\n            this.appendChild(fragment.content);\n            break;\n          }\n\n        case \"afterend\":\n          {\n            this.parentNode.insertBefore(fragment.content, this.nextSibling);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"closest\",\n    value: function closest(selectors) {\n      var matcher = addNwsapi(this);\n      return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n    }\n  }, {\n    key: \"namespaceURI\",\n    get: function get() {\n      return this._namespaceURI;\n    }\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return this._prefix;\n    }\n  }, {\n    key: \"localName\",\n    get: function get() {\n      return this._localName;\n    }\n  }, {\n    key: \"_qualifiedName\",\n    get: function get() {\n      return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n    }\n  }, {\n    key: \"tagName\",\n    get: function get() {\n      var qualifiedName = this._qualifiedName;\n\n      if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        qualifiedName = qualifiedName.toUpperCase();\n      }\n\n      return qualifiedName;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this._attributes;\n    }\n  }, {\n    key: \"outerHTML\",\n    get: function get() {\n      return domToHtml([this]);\n    },\n    set: function set(html) {\n      if (html === null) {\n        html = \"\";\n      }\n\n      var parent = domSymbolTree.parent(this);\n      var document = this._ownerDocument;\n\n      if (!parent) {\n        return;\n      }\n\n      var contextElement;\n\n      if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n      } else if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        contextElement = document.createElementNS(HTML_NS, \"body\");\n      } else if (parent.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        contextElement = clone(parent, undefined, false);\n      } else {\n        throw new TypeError(\"This should never happen\");\n      }\n\n      document._htmlToDom.appendToNode(html, contextElement);\n\n      while (contextElement.firstChild) {\n        parent.insertBefore(contextElement.firstChild, this);\n      }\n\n      parent.removeChild(this);\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      // TODO is this necessary? I would have thought this would be handled at a different level.\n      var tagName = this.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        var type = this.getAttribute(\"type\");\n\n        if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n          return domToHtml(domSymbolTree.childrenIterator(this));\n        }\n      } // In case of <template> we should pass its \"template contents\" fragment as a serialization root if we have one\n\n\n      if (this._templateContents) {\n        return domToHtml(domSymbolTree.childrenIterator(this._templateContents));\n      }\n\n      return domToHtml(domSymbolTree.childrenIterator(this));\n    },\n    set: function set(html) {\n      if (html === null) {\n        html = \"\";\n      }\n\n      setInnerHTML(this.ownerDocument, this, html);\n    }\n  }, {\n    key: \"classList\",\n    get: function get() {\n      if (this._classList === undefined) {\n        this._classList = DOMTokenList.createImpl([], {\n          element: this,\n          attributeLocalName: \"class\"\n        });\n      }\n\n      return this._classList;\n    }\n  }, {\n    key: \"scrollWidth\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"scrollHeight\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientTop\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientLeft\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientWidth\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientHeight\",\n    get: function get() {\n      return 0;\n    }\n  }]);\n\n  return ElementImpl;\n}(NodeImpl);\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\nElementImpl.prototype.matches = memoizeQuery(function (selectors) {\n  var matcher = addNwsapi(this);\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n});\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\nmodule.exports = {\n  implementation: ElementImpl\n};","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/nodes/Element-impl.js"],"names":["require","addNwsapi","HTML_NS","mixin","memoizeQuery","idlUtils","NodeImpl","implementation","ParentNodeImpl","ChildNodeImpl","attributes","namedPropertiesWindow","NODE_TYPE","domToHtml","domSymbolTree","DOMException","DOMTokenList","attrGenerated","NamedNodeMap","validateNames","asciiLowercase","clone","listOfElementsWithQualifiedName","listOfElementsWithNamespaceAndLocalName","listOfElementsWithClassNames","NonDocumentTypeChildNode","clearChildNodes","node","child","firstChild","removeChild","setInnerHTML","document","html","_templateContents","nodeName","_htmlToDom","appendToDocument","appendToNode","attachId","id","elm","doc","_ids","push","detachId","elms","i","length","splice","ElementImpl","args","privateData","nodeType","ELEMENT_NODE","scrollTop","scrollLeft","_namespaceURI","namespace","_prefix","_localName","localName","_attributeList","_attributesByNameMap","Map","_attributes","createImpl","element","nodeAttachedToDocument","getAttribute","_ownerDocument","nodeDetachedFromDocument","name","value","oldValue","_modified","elementAttributeModified","_attached","_classList","undefined","attrModified","hasAttributes","attributeNames","attr","getAttributeByName","_value","getAttributeByNameNS","_parsingMode","attribute","newAttr","appendAttribute","changeAttribute","extracted","validateAndExtract","setAttributeValue","prefix","removeAttributeByName","removeAttributeByNameNS","hasAttributeByName","hasAttributeByNameNS","setAttribute","hasAttribute","removeAttribute","bottom","height","left","right","top","width","position","text","toLowerCase","context","parentNode","DOCUMENT_NODE","fragment","ownerDocument","createElement","innerHTML","insertBefore","content","appendChild","nextSibling","selectors","matcher","closest","wrapperForImpl","qualifiedName","_qualifiedName","namespaceURI","toUpperCase","parent","contextElement","DOCUMENT_FRAGMENT_NODE","createElementNS","TypeError","tagName","type","test","childrenIterator","attributeLocalName","prototype","getElementsByTagName","getElementsByTagNameNS","getElementsByClassName","classNames","matches","match","webkitMatchesSelector","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst { addNwsapi } = require(\"../helpers/selectors\");\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { mixin, memoizeQuery } = require(\"../../utils\");\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\nconst attributes = require(\"../attributes\");\nconst namedPropertiesWindow = require(\"../named-properties-window\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { domToHtml } = require(\"../../browser/domtohtml\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst DOMException = require(\"domexception\");\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\nconst attrGenerated = require(\"../generated/Attr\");\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\nconst validateNames = require(\"../helpers/validate-names\");\nconst { asciiLowercase } = require(\"../helpers/strings\");\nconst { clone, listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames } = require(\"../node\");\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (node.nodeName === \"#document\") {\n    document._htmlToDom.appendToDocument(html, node);\n  } else {\n    document._htmlToDom.appendToNode(html, node);\n  }\n}\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this._namespaceURI = privateData.namespace || null;\n    this._prefix = null;\n    this._localName = privateData.localName;\n\n    this._attributeList = [];\n    // Used for caching.\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl([], {\n      element: this\n    });\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n\n    const id = this.getAttribute(\"id\");\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n\n    const id = this.getAttribute(\"id\");\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    }\n\n    // update classList\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n  get prefix() {\n    return this._prefix;\n  }\n  get localName() {\n    return this._localName;\n  }\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n  get tagName() {\n    let qualifiedName = this._qualifiedName;\n    if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n    return qualifiedName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  }\n\n  get outerHTML() {\n    return domToHtml([this]);\n  }\n\n  set outerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    const parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    let contextElement;\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n    } else if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      contextElement = document.createElementNS(HTML_NS, \"body\");\n    } else if (parent.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      contextElement = clone(parent, undefined, false);\n    } else {\n      throw new TypeError(\"This should never happen\");\n    }\n\n    document._htmlToDom.appendToNode(html, contextElement);\n\n    while (contextElement.firstChild) {\n      parent.insertBefore(contextElement.firstChild, this);\n    }\n\n    parent.removeChild(this);\n  }\n\n  get innerHTML() {\n    // TODO is this necessary? I would have thought this would be handled at a different level.\n    const { tagName } = this;\n    if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n      const type = this.getAttribute(\"type\");\n      if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n        return domToHtml(domSymbolTree.childrenIterator(this));\n      }\n    }\n\n    // In case of <template> we should pass its \"template contents\" fragment as a serialization root if we have one\n    if (this._templateContents) {\n      return domToHtml(domSymbolTree.childrenIterator(this._templateContents));\n    }\n\n    return domToHtml(domSymbolTree.childrenIterator(this));\n  }\n\n  set innerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    setInnerHTML(this.ownerDocument, this, html);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl([], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = attrGenerated.createImpl([], { localName: name, value });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(namespace, name);\n\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    if (!attributes.hasAttribute(this, attr)) {\n      throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n    }\n\n    attributes.removeAttribute(this, attr);\n\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n  insertAdjacentHTML(position, text) {\n    position = position.toLowerCase();\n\n    let context;\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\": {\n        context = this.parentNode;\n        if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n          throw new DOMException(\"Cannot insert HTML adjacent to \" +\n            \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n        }\n        break;\n      }\n      case \"afterbegin\":\n      case \"beforeend\": {\n        context = this;\n        break;\n      }\n      default: {\n        throw new DOMException(\"Must provide one of \\\"beforebegin\\\", \\\"afterend\\\", \" +\n          \"\\\"afterbegin\\\", or \\\"beforeend\\\".\", \"SyntaxError\");\n      }\n    }\n\n    // TODO: use context for parsing instead of a <template>.\n    const fragment = this.ownerDocument.createElement(\"template\");\n    fragment.innerHTML = text;\n\n    switch (position) {\n      case \"beforebegin\": {\n        this.parentNode.insertBefore(fragment.content, this);\n        break;\n      }\n      case \"afterbegin\": {\n        this.insertBefore(fragment.content, this.firstChild);\n        break;\n      }\n      case \"beforeend\": {\n        this.appendChild(fragment.content);\n        break;\n      }\n      case \"afterend\": {\n        this.parentNode.insertBefore(fragment.content, this.nextSibling);\n        break;\n      }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\n\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = memoizeQuery(function (selectors) {\n  const matcher = addNwsapi(this);\n\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n});\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\n\nmodule.exports = {\n  implementation: ElementImpl\n};\n"]},"metadata":{},"sourceType":"script"}