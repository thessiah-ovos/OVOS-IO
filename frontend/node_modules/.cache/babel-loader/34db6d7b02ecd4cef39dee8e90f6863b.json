{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _inherits = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nvar _require = require(\"child_process\"),\n    spawnSync = _require.spawnSync;\n\nvar _require2 = require(\"whatwg-url\"),\n    URL = _require2.URL;\n\nvar whatwgEncoding = require(\"whatwg-encoding\");\n\nvar tough = require(\"tough-cookie\");\n\nvar MIMEType = require(\"whatwg-mimetype\");\n\nvar conversions = require(\"webidl-conversions\");\n\nvar xhrUtils = require(\"./xhr-utils\");\n\nvar DOMException = require(\"domexception\");\n\nvar xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nvar _require3 = require(\"../utils\"),\n    addConstants = _require3.addConstants;\n\nvar _require4 = require(\"./helpers/document-base-url\"),\n    documentBaseURLSerialized = _require4.documentBaseURLSerialized;\n\nvar _require5 = require(\"./helpers/strings\"),\n    asciiCaseInsensitiveMatch = _require5.asciiCaseInsensitiveMatch;\n\nvar idlUtils = require(\"./generated/utils\");\n\nvar Document = require(\"./generated/Document\");\n\nvar Blob = require(\"./generated/Blob\");\n\nvar FormData = require(\"./generated/FormData\");\n\nvar XMLHttpRequestEventTarget = require(\"./generated/XMLHttpRequestEventTarget\");\n\nvar XMLHttpRequestUpload = require(\"./generated/XMLHttpRequestUpload\");\n\nvar _require6 = require(\"../browser/domtohtml\"),\n    domToHtml = _require6.domToHtml;\n\nvar _require7 = require(\"./helpers/create-event-accessor\"),\n    setupForSimpleEventAccessors = _require7.setupForSimpleEventAccessors;\n\nvar _require8 = require(\"./helpers/json\"),\n    parseJSONFromBytes = _require8.parseJSONFromBytes;\n\nvar syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nvar tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nvar fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nvar forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nvar forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nvar uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nvar corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nvar allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nvar forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\nvar XMLHttpRequestResponseType = new Set([\"\", \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  var Event = window.Event,\n      ProgressEvent = window.ProgressEvent;\n\n  var XMLHttpRequest = /*#__PURE__*/function (_XMLHttpRequestEventT) {\n    _inherits(XMLHttpRequest, _XMLHttpRequestEventT);\n\n    var _super = _createSuper(XMLHttpRequest);\n\n    function XMLHttpRequest() {\n      var _this;\n\n      _classCallCheck(this, XMLHttpRequest);\n\n      // eslint-disable-line constructor-super\n      var theThis = Object.create((this instanceof XMLHttpRequest ? this.constructor : void 0).prototype);\n      XMLHttpRequestEventTarget.setup(theThis);\n      theThis.upload = XMLHttpRequestUpload.create();\n      theThis.upload._ownerDocument = window.document;\n      theThis[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: theThis._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: theThis._ownerDocument._requestManager,\n        pool: theThis._ownerDocument._pool,\n        agentOptions: theThis._ownerDocument._agentOptions,\n        strictSSL: theThis._ownerDocument._strictSSL,\n        proxy: theThis._ownerDocument._proxy,\n        cookieJar: theThis._ownerDocument._cookieJar,\n        encoding: theThis._ownerDocument._encoding,\n        origin: theThis._ownerDocument.origin,\n        userAgent: window.navigator.userAgent\n      };\n      theThis[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: false,\n        uploadListener: false,\n        // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n        // In that case the termination reason is \"fatal\", not \"end-user abort\".\n        abortError: false,\n        cookieJar: theThis._ownerDocument._cookieJar,\n        bufferStepSize: 1 * 1024 * 1024,\n        // pre-allocate buffer increase step size. init value is 1MB\n        totalReceivedChunkSize: 0\n      };\n      return _possibleConstructorReturn(_this, theThis);\n    }\n\n    _createClass(XMLHttpRequest, [{\n      key: \"abort\",\n      value: function abort() {\n        var properties = this[xhrSymbols.properties]; // Terminate the request\n\n        clearTimeout(properties.timeoutId);\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n        var client = properties.client;\n\n        if (client) {\n          client.abort();\n          properties.client = null;\n        }\n\n        if (properties.abortError) {\n          // Special case that ideally shouldn't be going through the public API at all.\n          // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n          properties.readyState = XMLHttpRequest.DONE;\n          properties.send = false;\n          xhrUtils.setResponseToNetworkError(this);\n          return;\n        }\n\n        if (this.readyState === XMLHttpRequest.OPENED && properties.send || this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {\n          xhrUtils.requestErrorSteps(this, \"abort\");\n        }\n\n        if (this.readyState === XMLHttpRequest.DONE) {\n          properties.readyState = XMLHttpRequest.UNSENT;\n          xhrUtils.setResponseToNetworkError(this);\n        }\n      }\n    }, {\n      key: \"getAllResponseHeaders\",\n      value: function getAllResponseHeaders() {\n        var properties = this[xhrSymbols.properties];\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n          return \"\";\n        }\n\n        return Object.keys(properties.responseHeaders).filter(function (key) {\n          return properties.filteredResponseHeaders.indexOf(key) === -1;\n        }).map(function (key) {\n          return [conversions.ByteString(key).toLowerCase(), properties.responseHeaders[key]].join(\": \");\n        }).join(\"\\r\\n\");\n      }\n    }, {\n      key: \"getResponseHeader\",\n      value: function getResponseHeader(header) {\n        var properties = this[xhrSymbols.properties];\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n          return null;\n        }\n\n        var lcHeader = conversions.ByteString(header).toLowerCase();\n\n        if (properties.filteredResponseHeaders.find(function (filtered) {\n          return lcHeader === filtered.toLowerCase();\n        })) {\n          return null;\n        }\n\n        return _getResponseHeader(this, lcHeader);\n      }\n    }, {\n      key: \"open\",\n      value: function open(method, uri, asynchronous, user, password) {\n        if (!this._ownerDocument) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n        var argumentCount = arguments.length;\n\n        if (argumentCount < 2) {\n          throw new TypeError(\"Not enough arguments (expected at least 2)\");\n        }\n\n        method = conversions.ByteString(method);\n        uri = conversions.USVString(uri);\n\n        if (user) {\n          user = conversions.USVString(user);\n        }\n\n        if (password) {\n          password = conversions.USVString(password);\n        }\n\n        if (!tokenRegexp.test(method)) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        var upperCaseMethod = method.toUpperCase();\n\n        if (forbiddenRequestMethods.has(upperCaseMethod)) {\n          throw new DOMException(\"The operation is insecure.\", \"SecurityError\");\n        }\n\n        var client = properties.client;\n\n        if (client && typeof client.abort === \"function\") {\n          client.abort();\n        }\n\n        if (allowedRequestMethods.has(upperCaseMethod)) {\n          method = upperCaseMethod;\n        }\n\n        if (typeof asynchronous !== \"undefined\") {\n          flag.synchronous = !asynchronous;\n        } else {\n          flag.synchronous = false;\n        }\n\n        if (flag.responseType && flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        if (flag.synchronous && flag.timeout) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        flag.method = method;\n        var urlObj;\n\n        try {\n          urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n        } catch (e) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        if (user || password && !urlObj.username) {\n          flag.auth = {\n            user: user,\n            pass: password\n          };\n          urlObj.username = \"\";\n          urlObj.password = \"\";\n        }\n\n        flag.uri = urlObj.href;\n        flag.requestHeaders = {};\n        flag.preflight = false;\n        properties.send = false;\n        properties.uploadListener = false;\n        properties.requestBuffer = null;\n        properties.requestCache = null;\n        properties.abortError = false;\n        properties.responseURL = \"\";\n        readyStateChange(this, XMLHttpRequest.OPENED);\n      }\n    }, {\n      key: \"overrideMimeType\",\n      value: function overrideMimeType(mime) {\n        mime = String(mime);\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        this[xhrSymbols.flag].overrideMIMEType = \"application/octet-stream\"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n\n        var parsed = MIMEType.parse(mime);\n\n        if (parsed) {\n          this[xhrSymbols.flag].overrideMIMEType = parsed.essence;\n          var charset = parsed.parameters.get(\"charset\");\n\n          if (charset) {\n            this[xhrSymbols.flag].overrideCharset = whatwgEncoding.labelToName(charset);\n          }\n        }\n      }\n    }, {\n      key: \"send\",\n      value: function send(body) {\n        var _this2 = this;\n\n        body = coerceBodyArg(body); // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n\n        if (!this._ownerDocument) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        properties.beforeSend = true;\n\n        try {\n          if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n            body = null;\n          }\n\n          if (body !== null) {\n            var encoding = null;\n            var mimeType = null;\n\n            if (Document.isImpl(body)) {\n              encoding = \"UTF-8\";\n              mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n              flag.body = domToHtml([body]);\n            } else {\n              if (typeof body === \"string\") {\n                encoding = \"UTF-8\";\n              }\n\n              var _extractBody = extractBody(body),\n                  buffer = _extractBody.buffer,\n                  formData = _extractBody.formData,\n                  contentType = _extractBody.contentType;\n\n              mimeType = contentType;\n              flag.body = buffer || formData;\n              flag.formData = Boolean(formData);\n            }\n\n            var existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n            if (mimeType !== null && existingContentType === null) {\n              flag.requestHeaders[\"Content-Type\"] = mimeType;\n            } else if (existingContentType !== null && encoding !== null) {\n              // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n              // the spec will be, in the meantime.\n              var parsed = MIMEType.parse(existingContentType);\n\n              if (parsed) {\n                var charset = parsed.parameters.get(\"charset\");\n\n                if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n                  parsed.parameters.set(\"charset\", encoding);\n                }\n\n                xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n              }\n            }\n          }\n        } finally {\n          if (properties.beforeSend) {\n            properties.beforeSend = false;\n          } else {\n            throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n          }\n        }\n\n        if (Object.keys(idlUtils.implForWrapper(this.upload)._eventListeners).length > 0) {\n          properties.uploadListener = true;\n        } // request doesn't like zero-length bodies\n\n\n        if (flag.body && flag.body.byteLength === 0) {\n          flag.body = null;\n        }\n\n        if (flag.synchronous) {\n          var flagStr = JSON.stringify(flag, function (k, v) {\n            if (this === flag && k === \"requestManager\") {\n              return null;\n            }\n\n            if (this === flag && k === \"pool\" && v) {\n              return {\n                maxSockets: v.maxSockets\n              };\n            }\n\n            return v;\n          });\n          var res = spawnSync(process.execPath, [syncWorkerFile], {\n            input: flagStr\n          });\n\n          if (res.status !== 0) {\n            throw new Error(res.stderr.toString());\n          }\n\n          if (res.error) {\n            if (typeof res.error === \"string\") {\n              res.error = new Error(res.error);\n            }\n\n            throw res.error;\n          }\n\n          var response = JSON.parse(res.stdout.toString());\n\n          if (response.properties.responseBuffer && response.properties.responseBuffer.data) {\n            response.properties.responseBuffer = Buffer.from(response.properties.responseBuffer.data);\n          }\n\n          if (response.properties.cookieJar) {\n            response.properties.cookieJar = tough.CookieJar.deserializeSync(response.properties.cookieJar, this._ownerDocument._cookieJar.store);\n          }\n\n          response.properties.readyState = XMLHttpRequest.LOADING;\n          this[xhrSymbols.properties] = response.properties;\n\n          if (response.properties.error) {\n            xhrUtils.dispatchError(this);\n            throw new DOMException(response.properties.error, \"NetworkError\");\n          } else {\n            var responseBuffer = this[xhrSymbols.properties].responseBuffer;\n            var contentLength = _getResponseHeader(this, \"content-length\") || \"0\";\n            var bufferLength = parseInt(contentLength) || responseBuffer.length;\n            var progressObj = {\n              lengthComputable: false\n            };\n\n            if (bufferLength !== 0) {\n              progressObj.total = bufferLength;\n              progressObj.loaded = bufferLength;\n              progressObj.lengthComputable = true;\n            }\n\n            this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n            readyStateChange(this, XMLHttpRequest.DONE);\n            this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n            this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n          }\n        } else {\n          properties.send = true;\n          this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n          var client = xhrUtils.createClient(this);\n          properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize\n\n          properties.totalReceivedChunkSize = 0;\n          properties.bufferStepSize = 1 * 1024 * 1024;\n          properties.origin = flag.origin;\n          client.on(\"error\", function (err) {\n            client.removeAllListeners();\n            properties.error = err;\n            xhrUtils.dispatchError(_this2);\n          });\n          client.on(\"response\", function (res) {\n            return receiveResponse(_this2, res);\n          });\n          client.on(\"redirect\", function () {\n            var response = client.response;\n            var destUrlObj = new URL(response.request.headers.Referer);\n            var urlObj = new URL(response.request.uri.href);\n\n            if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n              properties.origin = \"null\";\n            }\n\n            response.request.headers.Origin = properties.origin;\n\n            if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n              if (!xhrUtils.validCORSHeaders(_this2, response, flag, properties, flag.origin)) {\n                return;\n              }\n\n              if (urlObj.username || urlObj.password) {\n                properties.error = \"Userinfo forbidden in cors redirect\";\n                xhrUtils.dispatchError(_this2);\n              }\n            }\n          });\n\n          if (body !== null && body !== \"\") {\n            properties.uploadComplete = false;\n            setDispatchProgressEvents(this);\n          } else {\n            properties.uploadComplete = true;\n          }\n\n          if (this.timeout > 0) {\n            properties.timeoutStart = new Date().getTime();\n\n            properties.timeoutFn = function () {\n              client.abort();\n\n              if (!(_this2.readyState === XMLHttpRequest.UNSENT || _this2.readyState === XMLHttpRequest.OPENED && !properties.send || _this2.readyState === XMLHttpRequest.DONE)) {\n                properties.send = false;\n                var stateChanged = false;\n\n                if (!properties.uploadComplete) {\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n\n                  readyStateChange(_this2, XMLHttpRequest.DONE);\n\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n\n                  stateChanged = true;\n                }\n\n                _this2.dispatchEvent(new ProgressEvent(\"progress\"));\n\n                if (!stateChanged) {\n                  readyStateChange(_this2, XMLHttpRequest.DONE);\n                }\n\n                _this2.dispatchEvent(new ProgressEvent(\"timeout\"));\n\n                _this2.dispatchEvent(new ProgressEvent(\"loadend\"));\n              }\n\n              properties.readyState = XMLHttpRequest.UNSENT;\n            };\n\n            properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n          }\n        }\n\n        flag.body = undefined;\n        flag.formData = false;\n      }\n    }, {\n      key: \"setRequestHeader\",\n      value: function setRequestHeader(header, value) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (arguments.length !== 2) {\n          throw new TypeError(\"2 arguments required for setRequestHeader\");\n        }\n\n        header = conversions.ByteString(header);\n        value = conversions.ByteString(value);\n\n        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        value = normalizeHeaderValue(value);\n\n        if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        var lcHeader = header.toLowerCase();\n\n        if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n          return;\n        }\n\n        var keys = Object.keys(flag.requestHeaders);\n        var n = keys.length;\n\n        while (n--) {\n          var key = keys[n];\n\n          if (key.toLowerCase() === lcHeader) {\n            flag.requestHeaders[key] += \", \" + value;\n            return;\n          }\n        }\n\n        flag.requestHeaders[header] = value;\n      }\n    }, {\n      key: \"readyState\",\n      get: function get() {\n        return this[xhrSymbols.properties].readyState;\n      }\n    }, {\n      key: \"status\",\n      get: function get() {\n        return this[xhrSymbols.properties].status;\n      }\n    }, {\n      key: \"statusText\",\n      get: function get() {\n        return this[xhrSymbols.properties].statusText;\n      }\n    }, {\n      key: \"responseType\",\n      get: function get() {\n        return this[xhrSymbols.flag].responseType;\n      },\n      set: function set(responseType) {\n        var flag = this[xhrSymbols.flag];\n\n        if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        if (!XMLHttpRequestResponseType.has(responseType)) {\n          responseType = \"\";\n        }\n\n        flag.responseType = responseType;\n      }\n    }, {\n      key: \"response\",\n      get: function get() {\n        var properties = this[xhrSymbols.properties];\n\n        if (properties.responseCache) {\n          return properties.responseCache;\n        }\n\n        var res = \"\";\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        switch (this.responseType) {\n          case \"\":\n          case \"text\":\n            {\n              res = this.responseText;\n              break;\n            }\n\n          case \"arraybuffer\":\n            {\n              if (!responseBuffer) {\n                return null;\n              }\n\n              res = new Uint8Array(responseBuffer).buffer;\n              break;\n            }\n\n          case \"blob\":\n            {\n              if (!responseBuffer) {\n                return null;\n              }\n\n              var contentType = finalMIMEType(this);\n              res = Blob.create([[new Uint8Array(responseBuffer)], {\n                type: contentType || \"\"\n              }]);\n              break;\n            }\n\n          case \"document\":\n            {\n              res = this.responseXML;\n              break;\n            }\n\n          case \"json\":\n            {\n              if (this.readyState !== XMLHttpRequest.DONE || !responseBuffer) {\n                res = null;\n              }\n\n              try {\n                res = parseJSONFromBytes(responseBuffer);\n              } catch (e) {\n                res = null;\n              }\n\n              break;\n            }\n        }\n\n        properties.responseCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseText\",\n      get: function get() {\n        var properties = this[xhrSymbols.properties];\n\n        if (this.responseType !== \"\" && this.responseType !== \"text\") {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n          return \"\";\n        }\n\n        if (properties.responseTextCache) {\n          return properties.responseTextCache;\n        }\n\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        if (!responseBuffer) {\n          return \"\";\n        }\n\n        var fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n        var res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n        properties.responseTextCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseXML\",\n      get: function get() {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (this.responseType !== \"\" && this.responseType !== \"document\") {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState !== XMLHttpRequest.DONE) {\n          return null;\n        }\n\n        if (properties.responseXMLCache) {\n          return properties.responseXMLCache;\n        }\n\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        if (!responseBuffer) {\n          return null;\n        }\n\n        var contentType = finalMIMEType(this);\n        var isHTML = false;\n        var isXML = false;\n        var parsed = MIMEType.parse(contentType);\n\n        if (parsed) {\n          isHTML = parsed.isHTML();\n          isXML = parsed.isXML();\n\n          if (!isXML && !isHTML) {\n            return null;\n          }\n        }\n\n        if (this.responseType === \"\" && isHTML) {\n          return null;\n        }\n\n        var encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n        var resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n        if (!resText) {\n          return null;\n        }\n\n        var res = Document.create([], {\n          options: {\n            url: flag.uri,\n            lastModified: new Date(_getResponseHeader(this, \"last-modified\")),\n            parsingMode: isHTML ? \"html\" : \"xml\",\n            cookieJar: {\n              setCookieSync: function setCookieSync() {\n                return undefined;\n              },\n              getCookieStringSync: function getCookieStringSync() {\n                return \"\";\n              }\n            },\n            encoding: encoding,\n            parseOptions: this._ownerDocument._parseOptions\n          }\n        });\n        var resImpl = idlUtils.implForWrapper(res);\n\n        try {\n          resImpl._htmlToDom.appendToDocument(resText, resImpl);\n        } catch (e) {\n          properties.responseXMLCache = null;\n          return null;\n        }\n\n        res.close();\n        properties.responseXMLCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseURL\",\n      get: function get() {\n        return this[xhrSymbols.properties].responseURL;\n      }\n    }, {\n      key: \"timeout\",\n      get: function get() {\n        return this[xhrSymbols.flag].timeout;\n      },\n      set: function set(val) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        flag.timeout = val;\n        clearTimeout(properties.timeoutId);\n\n        if (val > 0 && properties.timeoutFn) {\n          properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n        } else {\n          properties.timeoutFn = null;\n          properties.timeoutStart = 0;\n        }\n      }\n    }, {\n      key: \"withCredentials\",\n      get: function get() {\n        return this[xhrSymbols.flag].withCredentials;\n      },\n      set: function set(val) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        flag.withCredentials = val;\n      }\n    }, {\n      key: \"_ownerDocument\",\n      get: function get() {\n        return idlUtils.implForWrapper(window.document);\n      }\n    }]);\n\n    return XMLHttpRequest;\n  }(XMLHttpRequestEventTarget.interface);\n\n  Object.defineProperty(XMLHttpRequest.prototype, Symbol.toStringTag, {\n    value: \"XMLHttpRequest\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  setupForSimpleEventAccessors(XMLHttpRequest.prototype, [\"readystatechange\"]);\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    var properties = xhr[xhrSymbols.properties];\n\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n    var readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    var properties = xhr[xhrSymbols.properties];\n    var flag = xhr[xhrSymbols.flag];\n    var statusCode = response.statusCode;\n    var byteOffset = 0;\n    var headers = {};\n    var filteredResponseHeaders = [];\n    var headerMap = {};\n    var rawHeaders = response.rawHeaders;\n    var n = Number(rawHeaders.length);\n\n    for (var i = 0; i < n; i += 2) {\n      var k = rawHeaders[i];\n      var kl = k.toLowerCase();\n      var v = rawHeaders[i + 1];\n\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n\n      headerMap[kl] = k;\n    }\n\n    var destUrlObj = new URL(response.request.uri.href);\n\n    if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n      if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n\n      var acehStr = response.headers[\"access-control-expose-headers\"];\n      var aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n\n      for (var header in headers) {\n        var lcHeader = header.toLowerCase();\n\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (var _header in headers) {\n      var _lcHeader = _header.toLowerCase();\n\n      if (forbiddenResponseHeaders.has(_lcHeader)) {\n        filteredResponseHeaders.push(_header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n    var contentLength = _getResponseHeader(xhr, \"content-length\") || \"0\";\n    var bufferLength = parseInt(contentLength) || 0;\n    var progressObj = {\n      lengthComputable: false\n    };\n    var lastProgressReported;\n\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    } // pre-allocate buffer.\n\n\n    properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);\n\n    if (!properties.client) {\n      // The request was aborted in reaction to the readystatechange event.\n      return;\n    } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n\n\n    response.on(\"data\", function (chunk) {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n    properties.client.on(\"data\", function (chunk) {\n      properties.totalReceivedChunkSize += chunk.length;\n\n      if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n\n        while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n          properties.bufferStepSize *= 2;\n        }\n\n        var tmpBuf = Buffer.alloc(properties.bufferStepSize);\n        properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n        properties.responseBuffer = tmpBuf;\n      }\n\n      chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", function () {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    var properties = xhr[xhrSymbols.properties];\n    var client = properties.client;\n    var upload = xhr.upload;\n    var total = 0;\n    var lengthComputable = false;\n    var length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n\n    var initProgress = {\n      lengthComputable: lengthComputable,\n      total: total,\n      loaded: 0\n    };\n\n    if (properties.uploadListener) {\n      upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n    }\n\n    client.on(\"request\", function (req) {\n      req.on(\"response\", function () {\n        properties.uploadComplete = true;\n\n        if (!properties.uploadListener) {\n          return;\n        }\n\n        var progress = {\n          lengthComputable: lengthComputable,\n          total: total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  return XMLHttpRequest;\n};\n\nfunction finalMIMEType(xhr) {\n  var flag = xhr[xhrSymbols.flag];\n  return flag.overrideMIMEType || _getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  var flag = xhr[xhrSymbols.flag];\n\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n\n  var parsedContentType = MIMEType.parse(_getResponseHeader(xhr, \"content-type\"));\n\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n\n  return null;\n}\n\nfunction _getResponseHeader(xhr, lcHeader) {\n  var properties = xhr[xhrSymbols.properties];\n  var keys = Object.keys(properties.responseHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction coerceBodyArg(body) {\n  // Implements the IDL conversion for `optional (Document or BodyInit)? body = null`\n  if (body === undefined || body === null) {\n    return null;\n  }\n\n  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n    return body;\n  }\n\n  var impl = idlUtils.implForWrapper(body);\n\n  if (impl) {\n    // TODO: allow URLSearchParams or ReadableStream\n    if (Blob.isImpl(impl) || FormData.isImpl(impl) || Document.isImpl(impl)) {\n      return impl;\n    }\n  }\n\n  return conversions.USVString(body);\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (bodyInit instanceof ArrayBuffer) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    var formData = [];\n\n    var _iterator = _createForOfIteratorHelper(bodyInit._entries),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        var val = void 0;\n\n        if (Blob.isImpl(entry.value)) {\n          var blob = entry.value;\n          val = {\n            name: entry.name,\n            value: blob._buffer,\n            options: {\n              filename: blob.name,\n              contentType: blob.type,\n              knownLength: blob.size\n            }\n          };\n        } else {\n          val = entry;\n        }\n\n        formData.push(val);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      formData: formData\n    };\n  } // Must be a string\n\n\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/xmlhttprequest.js"],"names":["HTTP_STATUS_CODES","require","STATUS_CODES","spawnSync","URL","whatwgEncoding","tough","MIMEType","conversions","xhrUtils","DOMException","xhrSymbols","addConstants","documentBaseURLSerialized","asciiCaseInsensitiveMatch","idlUtils","Document","Blob","FormData","XMLHttpRequestEventTarget","XMLHttpRequestUpload","domToHtml","setupForSimpleEventAccessors","parseJSONFromBytes","syncWorkerFile","resolve","tokenRegexp","fieldValueRegexp","forbiddenRequestHeaders","Set","forbiddenResponseHeaders","uniqueResponseHeaders","corsSafeResponseHeaders","allowedRequestMethods","forbiddenRequestMethods","XMLHttpRequestResponseType","module","exports","createXMLHttpRequest","window","Event","ProgressEvent","XMLHttpRequest","theThis","Object","create","prototype","setup","upload","_ownerDocument","document","flag","synchronous","withCredentials","mimeType","auth","method","undefined","responseType","requestHeaders","referrer","uri","timeout","body","formData","preflight","requestManager","_requestManager","pool","_pool","agentOptions","_agentOptions","strictSSL","_strictSSL","proxy","_proxy","cookieJar","_cookieJar","encoding","_encoding","origin","userAgent","navigator","properties","beforeSend","send","timeoutStart","timeoutId","timeoutFn","client","responseHeaders","filteredResponseHeaders","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseURL","readyState","UNSENT","status","statusText","error","uploadComplete","uploadListener","abortError","bufferStepSize","totalReceivedChunkSize","clearTimeout","abort","DONE","setResponseToNetworkError","OPENED","HEADERS_RECEIVED","LOADING","requestErrorSteps","keys","filter","key","indexOf","map","ByteString","toLowerCase","join","header","lcHeader","find","filtered","getResponseHeader","asynchronous","user","password","argumentCount","arguments","length","TypeError","USVString","test","upperCaseMethod","toUpperCase","has","urlObj","e","username","pass","href","requestBuffer","requestCache","readyStateChange","mime","String","overrideMIMEType","parsed","parse","essence","charset","parameters","get","overrideCharset","labelToName","coerceBodyArg","isImpl","_parsingMode","extractBody","buffer","contentType","Boolean","existingContentType","getRequestHeader","set","updateRequestHeader","toString","implForWrapper","_eventListeners","byteLength","flagStr","JSON","stringify","k","v","maxSockets","res","process","execPath","input","Error","stderr","response","stdout","data","Buffer","from","CookieJar","deserializeSync","store","dispatchError","contentLength","bufferLength","parseInt","progressObj","lengthComputable","total","loaded","dispatchEvent","createClient","on","err","removeAllListeners","receiveResponse","destUrlObj","request","headers","Referer","Origin","protocol","validCORSHeaders","setDispatchProgressEvents","Date","getTime","stateChanged","setTimeout","value","normalizeHeaderValue","startsWith","n","slice","responseText","Uint8Array","finalMIMEType","type","responseXML","fallbackEncoding","finalCharset","getBOMEncoding","decode","isHTML","isXML","resText","options","url","lastModified","parsingMode","setCookieSync","getCookieStringSync","parseOptions","_parseOptions","resImpl","_htmlToDom","appendToDocument","close","val","Math","max","interface","defineProperty","Symbol","toStringTag","writable","enumerable","configurable","xhr","readyStateChangeEvent","statusCode","byteOffset","headerMap","rawHeaders","Number","i","kl","acehStr","aceh","trim","split","headerListSeparatorRegexp","push","statusMessage","lastProgressReported","alloc","chunk","tmpBuf","copy","initProgress","req","progress","parsedContentType","replace","ArrayBuffer","isView","impl","bodyInit","_buffer","_entries","entry","blob","name","filename","knownLength","size"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst { spawnSync } = require(\"child_process\");\nconst { URL } = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\nconst conversions = require(\"webidl-conversions\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\nconst { addConstants } = require(\"../utils\");\nconst { documentBaseURLSerialized } = require(\"./helpers/document-base-url\");\nconst { asciiCaseInsensitiveMatch } = require(\"./helpers/strings\");\nconst idlUtils = require(\"./generated/utils\");\nconst Document = require(\"./generated/Document\");\nconst Blob = require(\"./generated/Blob\");\nconst FormData = require(\"./generated/FormData\");\nconst XMLHttpRequestEventTarget = require(\"./generated/XMLHttpRequestEventTarget\");\nconst XMLHttpRequestUpload = require(\"./generated/XMLHttpRequestUpload\");\nconst { domToHtml } = require(\"../browser/domtohtml\");\nconst { setupForSimpleEventAccessors } = require(\"./helpers/create-event-accessor\");\nconst { parseJSONFromBytes } = require(\"./helpers/json\");\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nconst XMLHttpRequestResponseType = new Set([\n  \"\",\n  \"arraybuffer\",\n  \"blob\",\n  \"document\",\n  \"json\",\n  \"text\"\n]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  const { Event, ProgressEvent } = window;\n\n  class XMLHttpRequest extends XMLHttpRequestEventTarget.interface {\n    constructor() { // eslint-disable-line constructor-super\n      const theThis = Object.create(new.target.prototype);\n      XMLHttpRequestEventTarget.setup(theThis);\n      theThis.upload = XMLHttpRequestUpload.create();\n      theThis.upload._ownerDocument = window.document;\n\n      theThis[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: theThis._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: theThis._ownerDocument._requestManager,\n        pool: theThis._ownerDocument._pool,\n        agentOptions: theThis._ownerDocument._agentOptions,\n        strictSSL: theThis._ownerDocument._strictSSL,\n        proxy: theThis._ownerDocument._proxy,\n        cookieJar: theThis._ownerDocument._cookieJar,\n        encoding: theThis._ownerDocument._encoding,\n        origin: theThis._ownerDocument.origin,\n        userAgent: window.navigator.userAgent\n      };\n\n      theThis[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: false,\n        uploadListener: false,\n\n        // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n        // In that case the termination reason is \"fatal\", not \"end-user abort\".\n        abortError: false,\n\n        cookieJar: theThis._ownerDocument._cookieJar,\n        bufferStepSize: 1 * 1024 * 1024, // pre-allocate buffer increase step size. init value is 1MB\n        totalReceivedChunkSize: 0\n      };\n\n      return theThis;\n    }\n\n    get readyState() {\n      return this[xhrSymbols.properties].readyState;\n    }\n    get status() {\n      return this[xhrSymbols.properties].status;\n    }\n    get statusText() {\n      return this[xhrSymbols.properties].statusText;\n    }\n    get responseType() {\n      return this[xhrSymbols.flag].responseType;\n    }\n    set responseType(responseType) {\n      const flag = this[xhrSymbols.flag];\n      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n        throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n      }\n      if (!XMLHttpRequestResponseType.has(responseType)) {\n        responseType = \"\";\n      }\n      flag.responseType = responseType;\n    }\n    get response() {\n      const properties = this[xhrSymbols.properties];\n      if (properties.responseCache) {\n        return properties.responseCache;\n      }\n      let res = \"\";\n\n      const responseBuffer = properties.responseBuffer ?\n                             properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n                             null;\n\n      switch (this.responseType) {\n        case \"\":\n        case \"text\": {\n          res = this.responseText;\n          break;\n        }\n        case \"arraybuffer\": {\n          if (!responseBuffer) {\n            return null;\n          }\n          res = (new Uint8Array(responseBuffer)).buffer;\n          break;\n        }\n        case \"blob\": {\n          if (!responseBuffer) {\n            return null;\n          }\n          const contentType = finalMIMEType(this);\n          res = Blob.create([\n            [new Uint8Array(responseBuffer)],\n            { type: contentType || \"\" }\n          ]);\n          break;\n        }\n        case \"document\": {\n          res = this.responseXML;\n          break;\n        }\n        case \"json\": {\n          if (this.readyState !== XMLHttpRequest.DONE || !responseBuffer) {\n            res = null;\n          }\n\n          try {\n            res = parseJSONFromBytes(responseBuffer);\n          } catch (e) {\n            res = null;\n          }\n          break;\n        }\n      }\n      properties.responseCache = res;\n      return res;\n    }\n    get responseText() {\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"text\") {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n        return \"\";\n      }\n      if (properties.responseTextCache) {\n        return properties.responseTextCache;\n      }\n      const responseBuffer = properties.responseBuffer ?\n                             properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n                             null;\n\n      if (!responseBuffer) {\n        return \"\";\n      }\n\n      const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n      const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n      properties.responseTextCache = res;\n      return res;\n    }\n    get responseXML() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"document\") {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      if (this.readyState !== XMLHttpRequest.DONE) {\n        return null;\n      }\n      if (properties.responseXMLCache) {\n        return properties.responseXMLCache;\n      }\n      const responseBuffer = properties.responseBuffer ?\n                             properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n                             null;\n\n      if (!responseBuffer) {\n        return null;\n      }\n\n      const contentType = finalMIMEType(this);\n      let isHTML = false;\n      let isXML = false;\n      const parsed = MIMEType.parse(contentType);\n      if (parsed) {\n        isHTML = parsed.isHTML();\n        isXML = parsed.isXML();\n        if (!isXML && !isHTML) {\n          return null;\n        }\n      }\n\n      if (this.responseType === \"\" && isHTML) {\n        return null;\n      }\n\n      const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n      const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n      if (!resText) {\n        return null;\n      }\n      const res = Document.create([], { options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      } });\n      const resImpl = idlUtils.implForWrapper(res);\n      try {\n        resImpl._htmlToDom.appendToDocument(resText, resImpl);\n      } catch (e) {\n        properties.responseXMLCache = null;\n        return null;\n      }\n      res.close();\n      properties.responseXMLCache = res;\n      return res;\n    }\n\n    get responseURL() {\n      return this[xhrSymbols.properties].responseURL;\n    }\n\n    get timeout() {\n      return this[xhrSymbols.flag].timeout;\n    }\n    set timeout(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (flag.synchronous) {\n        throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n      }\n      flag.timeout = val;\n      clearTimeout(properties.timeoutId);\n      if (val > 0 && properties.timeoutFn) {\n        properties.timeoutId = setTimeout(\n          properties.timeoutFn,\n          Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n        );\n      } else {\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n      }\n    }\n    get withCredentials() {\n      return this[xhrSymbols.flag].withCredentials;\n    }\n    set withCredentials(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      if (properties.send) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      flag.withCredentials = val;\n    }\n\n    abort() {\n      const properties = this[xhrSymbols.properties];\n\n      // Terminate the request\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n\n      const { client } = properties;\n      if (client) {\n        client.abort();\n        properties.client = null;\n      }\n\n      if (properties.abortError) {\n        // Special case that ideally shouldn't be going through the public API at all.\n        // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n        properties.readyState = XMLHttpRequest.DONE;\n        properties.send = false;\n        xhrUtils.setResponseToNetworkError(this);\n        return;\n      }\n\n      if ((this.readyState === XMLHttpRequest.OPENED && properties.send) ||\n          this.readyState === XMLHttpRequest.HEADERS_RECEIVED ||\n          this.readyState === XMLHttpRequest.LOADING) {\n        xhrUtils.requestErrorSteps(this, \"abort\");\n      }\n\n      if (this.readyState === XMLHttpRequest.DONE) {\n        properties.readyState = XMLHttpRequest.UNSENT;\n\n        xhrUtils.setResponseToNetworkError(this);\n      }\n    }\n    getAllResponseHeaders() {\n      const properties = this[xhrSymbols.properties];\n      const { readyState } = this;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return \"\";\n      }\n      return Object.keys(properties.responseHeaders)\n        .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n        .map(key => [conversions.ByteString(key).toLowerCase(), properties.responseHeaders[key]].join(\": \"))\n        .join(\"\\r\\n\");\n    }\n\n    getResponseHeader(header) {\n      const properties = this[xhrSymbols.properties];\n      const { readyState } = this;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return null;\n      }\n      const lcHeader = conversions.ByteString(header).toLowerCase();\n      if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n        return null;\n      }\n      return getResponseHeader(this, lcHeader);\n    }\n\n    open(method, uri, asynchronous, user, password) {\n      if (!this._ownerDocument) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      const argumentCount = arguments.length;\n      if (argumentCount < 2) {\n        throw new TypeError(\"Not enough arguments (expected at least 2)\");\n      }\n\n      method = conversions.ByteString(method);\n      uri = conversions.USVString(uri);\n      if (user) {\n        user = conversions.USVString(user);\n      }\n      if (password) {\n        password = conversions.USVString(password);\n      }\n\n      if (!tokenRegexp.test(method)) {\n        throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n      }\n      const upperCaseMethod = method.toUpperCase();\n      if (forbiddenRequestMethods.has(upperCaseMethod)) {\n        throw new DOMException(\"The operation is insecure.\", \"SecurityError\");\n      }\n\n      const { client } = properties;\n      if (client && typeof client.abort === \"function\") {\n        client.abort();\n      }\n\n      if (allowedRequestMethods.has(upperCaseMethod)) {\n        method = upperCaseMethod;\n      }\n      if (typeof asynchronous !== \"undefined\") {\n        flag.synchronous = !asynchronous;\n      } else {\n        flag.synchronous = false;\n      }\n      if (flag.responseType && flag.synchronous) {\n        throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n      }\n      if (flag.synchronous && flag.timeout) {\n        throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n      }\n      flag.method = method;\n\n      let urlObj;\n      try {\n        urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n      } catch (e) {\n        throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n      }\n\n      if (user || (password && !urlObj.username)) {\n        flag.auth = {\n          user,\n          pass: password\n        };\n        urlObj.username = \"\";\n        urlObj.password = \"\";\n      }\n\n      flag.uri = urlObj.href;\n      flag.requestHeaders = {};\n      flag.preflight = false;\n\n      properties.send = false;\n      properties.uploadListener = false;\n      properties.requestBuffer = null;\n      properties.requestCache = null;\n      properties.abortError = false;\n      properties.responseURL = \"\";\n      readyStateChange(this, XMLHttpRequest.OPENED);\n    }\n\n    overrideMimeType(mime) {\n      mime = String(mime);\n\n      const { readyState } = this;\n      if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n\n      this[xhrSymbols.flag].overrideMIMEType = \"application/octet-stream\";\n\n      // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n      const parsed = MIMEType.parse(mime);\n      if (parsed) {\n        this[xhrSymbols.flag].overrideMIMEType = parsed.essence;\n\n        const charset = parsed.parameters.get(\"charset\");\n        if (charset) {\n          this[xhrSymbols.flag].overrideCharset = whatwgEncoding.labelToName(charset);\n        }\n      }\n    }\n\n    send(body) {\n      body = coerceBodyArg(body);\n\n      // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n      if (!this._ownerDocument) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n\n      properties.beforeSend = true;\n\n      try {\n        if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n          body = null;\n        }\n\n        if (body !== null) {\n          let encoding = null;\n          let mimeType = null;\n\n          if (Document.isImpl(body)) {\n            encoding = \"UTF-8\";\n            mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n            flag.body = domToHtml([body]);\n          } else {\n            if (typeof body === \"string\") {\n              encoding = \"UTF-8\";\n            }\n            const { buffer, formData, contentType } = extractBody(body);\n            mimeType = contentType;\n            flag.body = buffer || formData;\n            flag.formData = Boolean(formData);\n          }\n\n          const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n          if (mimeType !== null && existingContentType === null) {\n            flag.requestHeaders[\"Content-Type\"] = mimeType;\n          } else if (existingContentType !== null && encoding !== null) {\n            // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n            // the spec will be, in the meantime.\n            const parsed = MIMEType.parse(existingContentType);\n            if (parsed) {\n              const charset = parsed.parameters.get(\"charset\");\n              if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n                parsed.parameters.set(\"charset\", encoding);\n              }\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      } finally {\n        if (properties.beforeSend) {\n          properties.beforeSend = false;\n        } else {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n      }\n\n      if (Object.keys(idlUtils.implForWrapper(this.upload)._eventListeners).length > 0) {\n        properties.uploadListener = true;\n      }\n\n      // request doesn't like zero-length bodies\n      if (flag.body && flag.body.byteLength === 0) {\n        flag.body = null;\n      }\n\n      if (flag.synchronous) {\n        const flagStr = JSON.stringify(flag, function (k, v) {\n          if (this === flag && k === \"requestManager\") {\n            return null;\n          }\n          if (this === flag && k === \"pool\" && v) {\n            return { maxSockets: v.maxSockets };\n          }\n          return v;\n        });\n        const res = spawnSync(\n          process.execPath,\n          [syncWorkerFile],\n          { input: flagStr }\n        );\n        if (res.status !== 0) {\n          throw new Error(res.stderr.toString());\n        }\n        if (res.error) {\n          if (typeof res.error === \"string\") {\n            res.error = new Error(res.error);\n          }\n          throw res.error;\n        }\n\n        const response = JSON.parse(res.stdout.toString());\n        if (response.properties.responseBuffer && response.properties.responseBuffer.data) {\n          response.properties.responseBuffer = Buffer.from(response.properties.responseBuffer.data);\n        }\n        if (response.properties.cookieJar) {\n          response.properties.cookieJar = tough.CookieJar.deserializeSync(\n            response.properties.cookieJar,\n            this._ownerDocument._cookieJar.store\n          );\n        }\n\n        response.properties.readyState = XMLHttpRequest.LOADING;\n        this[xhrSymbols.properties] = response.properties;\n\n        if (response.properties.error) {\n          xhrUtils.dispatchError(this);\n          throw new DOMException(response.properties.error, \"NetworkError\");\n        } else {\n          const { responseBuffer } = this[xhrSymbols.properties];\n          const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n          const bufferLength = parseInt(contentLength) || responseBuffer.length;\n          const progressObj = { lengthComputable: false };\n          if (bufferLength !== 0) {\n            progressObj.total = bufferLength;\n            progressObj.loaded = bufferLength;\n            progressObj.lengthComputable = true;\n          }\n          this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n          readyStateChange(this, XMLHttpRequest.DONE);\n          this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n          this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n        }\n      } else {\n        properties.send = true;\n\n        this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n\n        const client = xhrUtils.createClient(this);\n\n        properties.client = client;\n        // For new client, reset totalReceivedChunkSize and bufferStepSize\n        properties.totalReceivedChunkSize = 0;\n        properties.bufferStepSize = 1 * 1024 * 1024;\n\n        properties.origin = flag.origin;\n\n        client.on(\"error\", err => {\n          client.removeAllListeners();\n          properties.error = err;\n          xhrUtils.dispatchError(this);\n        });\n\n        client.on(\"response\", res => receiveResponse(this, res));\n\n        client.on(\"redirect\", () => {\n          const { response } = client;\n          const destUrlObj = new URL(response.request.headers.Referer);\n\n          const urlObj = new URL(response.request.uri.href);\n\n          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n            properties.origin = \"null\";\n          }\n\n          response.request.headers.Origin = properties.origin;\n\n          if (flag.origin !== destUrlObj.origin &&\n              destUrlObj.protocol !== \"data:\") {\n            if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n              return;\n            }\n            if (urlObj.username || urlObj.password) {\n              properties.error = \"Userinfo forbidden in cors redirect\";\n              xhrUtils.dispatchError(this);\n            }\n          }\n        });\n        if (body !== null && body !== \"\") {\n          properties.uploadComplete = false;\n          setDispatchProgressEvents(this);\n        } else {\n          properties.uploadComplete = true;\n        }\n        if (this.timeout > 0) {\n          properties.timeoutStart = (new Date()).getTime();\n          properties.timeoutFn = () => {\n            client.abort();\n            if (!(this.readyState === XMLHttpRequest.UNSENT ||\n                (this.readyState === XMLHttpRequest.OPENED && !properties.send) ||\n                this.readyState === XMLHttpRequest.DONE)) {\n              properties.send = false;\n              let stateChanged = false;\n              if (!properties.uploadComplete) {\n                this.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n                readyStateChange(this, XMLHttpRequest.DONE);\n                this.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n                this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n                stateChanged = true;\n              }\n              this.dispatchEvent(new ProgressEvent(\"progress\"));\n              if (!stateChanged) {\n                readyStateChange(this, XMLHttpRequest.DONE);\n              }\n              this.dispatchEvent(new ProgressEvent(\"timeout\"));\n              this.dispatchEvent(new ProgressEvent(\"loadend\"));\n            }\n            properties.readyState = XMLHttpRequest.UNSENT;\n          };\n          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n        }\n      }\n      flag.body = undefined;\n      flag.formData = false;\n    }\n\n    setRequestHeader(header, value) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (arguments.length !== 2) {\n        throw new TypeError(\"2 arguments required for setRequestHeader\");\n      }\n      header = conversions.ByteString(header);\n      value = conversions.ByteString(value);\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n      }\n\n      value = normalizeHeaderValue(value);\n\n      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n        throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n      }\n\n      const lcHeader = header.toLowerCase();\n\n      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n        return;\n      }\n\n      const keys = Object.keys(flag.requestHeaders);\n      let n = keys.length;\n      while (n--) {\n        const key = keys[n];\n        if (key.toLowerCase() === lcHeader) {\n          flag.requestHeaders[key] += \", \" + value;\n          return;\n        }\n      }\n      flag.requestHeaders[header] = value;\n    }\n\n    get _ownerDocument() {\n      return idlUtils.implForWrapper(window.document);\n    }\n  }\n\n  Object.defineProperty(XMLHttpRequest.prototype, Symbol.toStringTag, {\n    value: \"XMLHttpRequest\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  setupForSimpleEventAccessors(XMLHttpRequest.prototype, [\"readystatechange\"]);\n\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    const properties = xhr[xhrSymbols.properties];\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n\n    const readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    const properties = xhr[xhrSymbols.properties];\n    const flag = xhr[xhrSymbols.flag];\n\n    const { statusCode } = response;\n\n    let byteOffset = 0;\n\n    const headers = {};\n    const filteredResponseHeaders = [];\n    const headerMap = {};\n    const { rawHeaders } = response;\n    const n = Number(rawHeaders.length);\n    for (let i = 0; i < n; i += 2) {\n      const k = rawHeaders[i];\n      const kl = k.toLowerCase();\n      const v = rawHeaders[i + 1];\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n      headerMap[kl] = k;\n    }\n\n    const destUrlObj = new URL(response.request.uri.href);\n    if (properties.origin !== destUrlObj.origin &&\n        destUrlObj.protocol !== \"data:\") {\n      if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n      const acehStr = response.headers[\"access-control-expose-headers\"];\n      const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n      for (const header in headers) {\n        const lcHeader = header.toLowerCase();\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (forbiddenResponseHeaders.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n\n    const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n    const bufferLength = parseInt(contentLength) || 0;\n    const progressObj = { lengthComputable: false };\n    let lastProgressReported;\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    }\n    // pre-allocate buffer.\n    properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);\n\n    if (!properties.client) {\n      // The request was aborted in reaction to the readystatechange event.\n      return;\n    }\n\n    // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n    response.on(\"data\", chunk => {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n\n    properties.client.on(\"data\", chunk => {\n      properties.totalReceivedChunkSize += chunk.length;\n      if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n        while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n          properties.bufferStepSize *= 2;\n        }\n        const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n        properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n        properties.responseBuffer = tmpBuf;\n      }\n      chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", () => {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    const { client } = properties;\n    const { upload } = xhr;\n\n    let total = 0;\n    let lengthComputable = false;\n    const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n    const initProgress = {\n      lengthComputable,\n      total,\n      loaded: 0\n    };\n\n    if (properties.uploadListener) {\n      upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n    }\n\n    client.on(\"request\", req => {\n      req.on(\"response\", () => {\n        properties.uploadComplete = true;\n\n        if (!properties.uploadListener) {\n          return;\n        }\n\n        const progress = {\n          lengthComputable,\n          total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  return XMLHttpRequest;\n};\n\nfunction finalMIMEType(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const properties = xhr[xhrSymbols.properties];\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction coerceBodyArg(body) {\n  // Implements the IDL conversion for `optional (Document or BodyInit)? body = null`\n\n  if (body === undefined || body === null) {\n    return null;\n  }\n\n  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n    return body;\n  }\n\n  const impl = idlUtils.implForWrapper(body);\n  if (impl) {\n    // TODO: allow URLSearchParams or ReadableStream\n    if (Blob.isImpl(impl) || FormData.isImpl(impl) || Document.isImpl(impl)) {\n      return impl;\n    }\n  }\n\n  return conversions.USVString(body);\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (bodyInit instanceof ArrayBuffer) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return { formData };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n"]},"metadata":{},"sourceType":"script"}