{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nvar notImplemented = require(\"../../browser/not-implemented\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar _require = require(\"../../utils\"),\n    Canvas = _require.Canvas;\n\nvar HTMLCanvasElementImpl = /*#__PURE__*/function (_HTMLElementImpl) {\n  _inherits(HTMLCanvasElementImpl, _HTMLElementImpl);\n\n  var _super = _createSuper(HTMLCanvasElementImpl);\n\n  function HTMLCanvasElementImpl() {\n    _classCallCheck(this, HTMLCanvasElementImpl);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HTMLCanvasElementImpl, [{\n    key: \"_attrModified\",\n    value: function _attrModified(name, value) {\n      if (this._canvas && (name === \"width\" || name === \"height\")) {\n        this._canvas[name] = parseInt(value);\n      }\n\n      return _get(_getPrototypeOf(HTMLCanvasElementImpl.prototype), \"_attrModified\", this).apply(this, arguments);\n    }\n  }, {\n    key: \"_getCanvas\",\n    value: function _getCanvas() {\n      if (Canvas && !this._canvas) {\n        this._canvas = new Canvas(this.width, this.height);\n      }\n\n      return this._canvas;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(contextId) {\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        if (!this._context) {\n          this._context = canvas.getContext(contextId) || null;\n\n          if (this._context) {\n            // Override the native canvas reference with our wrapper. This is the\n            // reason why we need to locally cache _context, since each call to\n            // canvas.getContext(contextId) would replace this reference again.\n            // Perhaps in the longer term, a better solution would be to create a\n            // full wrapper for the Context object as well.\n            this._context.canvas = idlUtils.wrapperForImpl(this);\n            wrapNodeCanvasMethod(this._context, \"createPattern\");\n            wrapNodeCanvasMethod(this._context, \"drawImage\");\n          }\n        }\n\n        return this._context;\n      }\n\n      notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n      return null;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() {\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        return canvas.toDataURL.apply(this._canvas, arguments);\n      }\n\n      notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n      return null;\n    }\n  }, {\n    key: \"toBlob\",\n    value: function toBlob(callback, type, qualityArgument) {\n      var window = this._ownerDocument._defaultView;\n\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        var stream;\n\n        switch (type) {\n          case \"image/jpg\":\n          case \"image/jpeg\":\n            stream = canvas.createJPEGStream({\n              quality: Math.max(0, Math.min(1, qualityArgument)) * 100\n            });\n            break;\n\n          default:\n            // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n            type = \"image/png\";\n            stream = canvas.createPNGStream();\n        }\n\n        var buffers = [];\n        stream.on(\"data\", function (chunk) {\n          buffers.push(chunk);\n        });\n        stream.on(\"end\", function () {\n          callback(new window.Blob(buffers, {\n            type: type\n          }));\n        });\n      } else {\n        notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      var parsed = parseInt(this.getAttribute(\"width\"));\n      return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n    },\n    set: function set(v) {\n      v = v > 2147483647 ? 300 : v;\n      this.setAttribute(\"width\", String(v));\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      var parsed = parseInt(this.getAttribute(\"height\"));\n      return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n    },\n    set: function set(v) {\n      v = v > 2147483647 ? 150 : v;\n      this.setAttribute(\"height\", String(v));\n    }\n  }]);\n\n  return HTMLCanvasElementImpl;\n}(HTMLElementImpl); // We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\n\n\nfunction wrapNodeCanvasMethod(ctx, name) {\n  var prev = ctx[name];\n\n  ctx[name] = function (image) {\n    var impl = idlUtils.implForWrapper(image);\n\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n\n    return prev.apply(ctx, arguments);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js"],"names":["HTMLElementImpl","require","implementation","notImplemented","idlUtils","Canvas","HTMLCanvasElementImpl","name","value","_canvas","parseInt","apply","arguments","width","height","contextId","canvas","_getCanvas","_context","getContext","wrapperForImpl","wrapNodeCanvasMethod","_ownerDocument","_defaultView","toDataURL","callback","type","qualityArgument","window","stream","createJPEGStream","quality","Math","max","min","createPNGStream","buffers","on","chunk","push","Blob","parsed","getAttribute","isNaN","v","setAttribute","String","ctx","prev","image","impl","implForWrapper","_image","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst { Canvas } = require(\"../../utils\");\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    return super._attrModified.apply(this, arguments);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = new Canvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toDataURL() {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL.apply(this._canvas, arguments);\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      let stream;\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          stream = canvas.createJPEGStream({\n            quality: Math.max(0, Math.min(1, qualityArgument)) * 100\n          });\n          break;\n        default:\n          // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n          type = \"image/png\";\n          stream = canvas.createPNGStream();\n      }\n      const buffers = [];\n      stream.on(\"data\", chunk => {\n        buffers.push(chunk);\n      });\n      stream.on(\"end\", () => {\n        callback(new window.Blob(buffers, { type }));\n      });\n    } else {\n      notImplemented(\n        \"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\",\n        window\n      );\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttribute(\"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttribute(\"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttribute(\"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttribute(\"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n    return prev.apply(ctx, arguments);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};\n"]},"metadata":{},"sourceType":"script"}