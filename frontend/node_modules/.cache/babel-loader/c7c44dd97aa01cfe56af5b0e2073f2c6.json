{"ast":null,"code":"'use strict';\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SymbolTreeNode = require('./SymbolTreeNode');\n\nvar TreePosition = require('./TreePosition');\n\nvar TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n  return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nvar SymbolTree = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @alias module:symbol-tree\n   * @param {string} [description='SymbolTree data'] Description used for the Symbol\n   */\n  function SymbolTree(description) {\n    _classCallCheck(this, SymbolTree);\n\n    this.symbol = Symbol(description || 'SymbolTree data');\n  }\n  /**\n   * You can use this function to (optionally) initialize an object right after its creation,\n   * to take advantage of V8's fast properties. Also useful if you would like to\n   * freeze your object.\n   *\n   * `O(1)`\n   *\n   * @method\n   * @alias module:symbol-tree#initialize\n   * @param {Object} object\n   * @return {Object} object\n   */\n\n\n  _createClass(SymbolTree, [{\n    key: \"initialize\",\n    value: function initialize(object) {\n      this._node(object);\n\n      return object;\n    }\n  }, {\n    key: \"_node\",\n    value: function _node(object) {\n      if (!object) {\n        return null;\n      }\n\n      var node = object[this.symbol];\n\n      if (node) {\n        return node;\n      }\n\n      return object[this.symbol] = new SymbolTreeNode();\n    }\n    /**\n     * Returns `true` if the object has any children. Otherwise it returns `false`.\n     *\n     * * `O(1)`\n     *\n     * @method hasChildren\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(object) {\n      return this._node(object).hasChildren;\n    }\n    /**\n     * Returns the first child of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method firstChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(object) {\n      return this._node(object).firstChild;\n    }\n    /**\n     * Returns the last child of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method lastChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"lastChild\",\n    value: function lastChild(object) {\n      return this._node(object).lastChild;\n    }\n    /**\n     * Returns the previous sibling of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method previousSibling\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"previousSibling\",\n    value: function previousSibling(object) {\n      return this._node(object).previousSibling;\n    }\n    /**\n     * Returns the next sibling of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method nextSibling\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling(object) {\n      return this._node(object).nextSibling;\n    }\n    /**\n     * Return the parent of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method parent\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(object) {\n      return this._node(object).parent;\n    }\n    /**\n     * Find the inclusive descendant that is last in tree order of the given object.\n     *\n     * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n     *\n     * @method lastInclusiveDescendant\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"lastInclusiveDescendant\",\n    value: function lastInclusiveDescendant(object) {\n      var lastChild;\n      var current = object;\n\n      while (lastChild = this._node(current).lastChild) {\n        current = lastChild;\n      }\n\n      return current;\n    }\n    /**\n     * Find the preceding object (A) of the given object (B).\n     * An object A is preceding an object B if A and B are in the same tree\n     * and A comes before B in tree order.\n     *\n     * * `O(n)` (worst case)\n     * * `O(1)` (amortized when walking the entire tree)\n     *\n     * @method preceding\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @param {Object} [options]\n     * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n     *        of the return value (or else null is returned). This check _assumes_\n     *        that `root` is also an inclusive ancestor of the given `object`\n     * @return {?Object}\n     */\n\n  }, {\n    key: \"preceding\",\n    value: function preceding(object, options) {\n      var treeRoot = options && options.root;\n\n      if (object === treeRoot) {\n        return null;\n      }\n\n      var previousSibling = this._node(object).previousSibling;\n\n      if (previousSibling) {\n        return this.lastInclusiveDescendant(previousSibling);\n      } // if there is no previous sibling return the parent (might be null)\n\n\n      return this._node(object).parent;\n    }\n    /**\n     * Find the following object (A) of the given object (B).\n     * An object A is following an object B if A and B are in the same tree\n     * and A comes after B in tree order.\n     *\n     * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n     * * `O(1)` (amortized when walking the entire tree)\n     *\n     * @method following\n     * @memberOf module:symbol-tree#\n     * @param {!Object} object\n     * @param {Object} [options]\n     * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n     *        of the return value (or else null is returned). This check _assumes_\n     *        that `root` is also an inclusive ancestor of the given `object`\n     * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n     * @return {?Object}\n     */\n\n  }, {\n    key: \"following\",\n    value: function following(object, options) {\n      var treeRoot = options && options.root;\n      var skipChildren = options && options.skipChildren;\n\n      var firstChild = !skipChildren && this._node(object).firstChild;\n\n      if (firstChild) {\n        return firstChild;\n      }\n\n      var current = object;\n\n      do {\n        if (current === treeRoot) {\n          return null;\n        }\n\n        var nextSibling = this._node(current).nextSibling;\n\n        if (nextSibling) {\n          return nextSibling;\n        }\n\n        current = this._node(current).parent;\n      } while (current);\n\n      return null;\n    }\n    /**\n     * Append all children of the given object to an array.\n     *\n     * * `O(n)` where `n` is the amount of children of the given `parent`\n     *\n     * @method childrenToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"childrenToArray\",\n    value: function childrenToArray(parent, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n\n      var parentNode = this._node(parent);\n\n      var object = parentNode.firstChild;\n      var index = 0;\n\n      while (object) {\n        var node = this._node(object);\n\n        node.setCachedIndex(parentNode, index);\n\n        if (filter.call(thisArg, object)) {\n          array.push(object);\n        }\n\n        object = node.nextSibling;\n        ++index;\n      }\n\n      return array;\n    }\n    /**\n     * Append all inclusive ancestors of the given object to an array.\n     *\n     * * `O(n)` where `n` is the amount of ancestors of the given `object`\n     *\n     * @method ancestorsToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"ancestorsToArray\",\n    value: function ancestorsToArray(object, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n      var ancestor = object;\n\n      while (ancestor) {\n        if (filter.call(thisArg, ancestor)) {\n          array.push(ancestor);\n        }\n\n        ancestor = this._node(ancestor).parent;\n      }\n\n      return array;\n    }\n    /**\n     * Append all descendants of the given object to an array (in tree order).\n     *\n     * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n     *\n     * @method treeToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} root\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"treeToArray\",\n    value: function treeToArray(root, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n      var object = root;\n\n      while (object) {\n        if (filter.call(thisArg, object)) {\n          array.push(object);\n        }\n\n        object = this.following(object, {\n          root: root\n        });\n      }\n\n      return array;\n    }\n    /**\n     * Iterate over all children of the given object\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method childrenIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @param {Object} [options]\n     * @param {Boolean} [options.reverse=false]\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"childrenIterator\",\n    value: function childrenIterator(parent, options) {\n      var reverse = options && options.reverse;\n\n      var parentNode = this._node(parent);\n\n      return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n    }\n    /**\n     * Iterate over all the previous siblings of the given object. (in reverse tree order)\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method previousSiblingsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"previousSiblingsIterator\",\n    value: function previousSiblingsIterator(object) {\n      return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n    }\n    /**\n     * Iterate over all the next siblings of the given object. (in tree order)\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method nextSiblingsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"nextSiblingsIterator\",\n    value: function nextSiblingsIterator(object) {\n      return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n    }\n    /**\n     * Iterate over all inclusive ancestors of the given object\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method ancestorsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"ancestorsIterator\",\n    value: function ancestorsIterator(object) {\n      return new TreeIterator(this, object, object, TreeIterator.PARENT);\n    }\n    /**\n     * Iterate over all descendants of the given object (in tree order).\n     *\n     * Where `n` is the amount of objects in the sub-tree of the given `root`:\n     *\n     * * `O(n)` (worst case for a single iteration)\n     * * `O(n)` (amortized, when completing the iterator)\n     *\n     * @method treeIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} root\n     * @param {Object} options\n     * @param {Boolean} [options.reverse=false]\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"treeIterator\",\n    value: function treeIterator(root, options) {\n      var reverse = options && options.reverse;\n      return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n    }\n    /**\n     * Find the index of the given object (the number of preceding siblings).\n     *\n     * * `O(n)` where `n` is the amount of preceding siblings\n     * * `O(1)` (amortized, if the tree is not modified)\n     *\n     * @method index\n     * @memberOf module:symbol-tree#\n     * @param {Object} child\n     * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n     */\n\n  }, {\n    key: \"index\",\n    value: function index(child) {\n      var childNode = this._node(child);\n\n      var parentNode = this._node(childNode.parent);\n\n      if (!parentNode) {\n        // In principal, you could also find out the number of preceding siblings\n        // for objects that do not have a parent. This method limits itself only to\n        // objects that have a parent because that lets us optimize more.\n        return -1;\n      }\n\n      var currentIndex = childNode.getCachedIndex(parentNode);\n\n      if (currentIndex >= 0) {\n        return currentIndex;\n      }\n\n      currentIndex = 0;\n      var object = parentNode.firstChild;\n\n      if (parentNode.childIndexCachedUpTo) {\n        var cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n\n        object = cachedUpToNode.nextSibling;\n        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n      }\n\n      while (object) {\n        var node = this._node(object);\n\n        node.setCachedIndex(parentNode, currentIndex);\n\n        if (object === child) {\n          break;\n        }\n\n        ++currentIndex;\n        object = node.nextSibling;\n      }\n\n      parentNode.childIndexCachedUpTo = child;\n      return currentIndex;\n    }\n    /**\n     * Calculate the number of children.\n     *\n     * * `O(n)` where `n` is the amount of children\n     * * `O(1)` (amortized, if the tree is not modified)\n     *\n     * @method childrenCount\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @return {Number}\n     */\n\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount(parent) {\n      var parentNode = this._node(parent);\n\n      if (!parentNode.lastChild) {\n        return 0;\n      }\n\n      return this.index(parentNode.lastChild) + 1;\n    }\n    /**\n     * Compare the position of an object relative to another object. A bit set is returned:\n     *\n     * <ul>\n     *     <li>DISCONNECTED : 1</li>\n     *     <li>PRECEDING : 2</li>\n     *     <li>FOLLOWING : 4</li>\n     *     <li>CONTAINS : 8</li>\n     *     <li>CONTAINED_BY : 16</li>\n     * </ul>\n     *\n     * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n     * DISCONNECTED never occurs with any other bit.\n     *\n     * where `n` and `m` are the amount of ancestors of `left` and `right`;\n     * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n     *\n     * * `O(n + m + o)` (worst case)\n     * * `O(n + m)` (amortized, if the tree is not modified)\n     *\n     * @method compareTreePosition\n     * @memberOf module:symbol-tree#\n     * @param {Object} left\n     * @param {Object} right\n     * @return {Number}\n     */\n\n  }, {\n    key: \"compareTreePosition\",\n    value: function compareTreePosition(left, right) {\n      // In DOM terms:\n      // left = reference / context object\n      // right = other\n      if (left === right) {\n        return 0;\n      }\n      /* jshint -W016 */\n\n\n      var leftAncestors = [];\n      {\n        // inclusive\n        var leftAncestor = left;\n\n        while (leftAncestor) {\n          if (leftAncestor === right) {\n            return TreePosition.CONTAINS | TreePosition.PRECEDING; // other is ancestor of reference\n          }\n\n          leftAncestors.push(leftAncestor);\n          leftAncestor = this.parent(leftAncestor);\n        }\n      }\n      var rightAncestors = [];\n      {\n        var rightAncestor = right;\n\n        while (rightAncestor) {\n          if (rightAncestor === left) {\n            return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n          }\n\n          rightAncestors.push(rightAncestor);\n          rightAncestor = this.parent(rightAncestor);\n        }\n      }\n      var root = reverseArrayIndex(leftAncestors, 0);\n\n      if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n        // note: unlike DOM, preceding / following is not set here\n        return TreePosition.DISCONNECTED;\n      } // find the lowest common ancestor\n\n\n      var commonAncestorIndex = 0;\n      var ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n      for (var i = 0; i < ancestorsMinLength; ++i) {\n        var _leftAncestor = reverseArrayIndex(leftAncestors, i);\n\n        var _rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n        if (_leftAncestor !== _rightAncestor) {\n          break;\n        }\n\n        commonAncestorIndex = i;\n      } // indexes within the common ancestor\n\n\n      var leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n      var rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n      return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n    }\n    /**\n     * Remove the object from this tree.\n     * Has no effect if already removed.\n     *\n     * * `O(1)`\n     *\n     * @method remove\n     * @memberOf module:symbol-tree#\n     * @param {Object} removeObject\n     * @return {Object} removeObject\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(removeObject) {\n      var removeNode = this._node(removeObject);\n\n      var parentNode = this._node(removeNode.parent);\n\n      var prevNode = this._node(removeNode.previousSibling);\n\n      var nextNode = this._node(removeNode.nextSibling);\n\n      if (parentNode) {\n        if (parentNode.firstChild === removeObject) {\n          parentNode.firstChild = removeNode.nextSibling;\n        }\n\n        if (parentNode.lastChild === removeObject) {\n          parentNode.lastChild = removeNode.previousSibling;\n        }\n      }\n\n      if (prevNode) {\n        prevNode.nextSibling = removeNode.nextSibling;\n      }\n\n      if (nextNode) {\n        nextNode.previousSibling = removeNode.previousSibling;\n      }\n\n      removeNode.parent = null;\n      removeNode.previousSibling = null;\n      removeNode.nextSibling = null;\n      removeNode.cachedIndex = -1;\n      removeNode.cachedIndexVersion = NaN;\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return removeObject;\n    }\n    /**\n     * Insert the given object before the reference object.\n     * `newObject` is now the previous sibling of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method insertBefore\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var prevNode = this._node(referenceNode.previousSibling);\n\n      var newNode = this._node(newObject);\n\n      var parentNode = this._node(referenceNode.parent);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      newNode.parent = referenceNode.parent;\n      newNode.previousSibling = referenceNode.previousSibling;\n      newNode.nextSibling = referenceObject;\n      referenceNode.previousSibling = newObject;\n\n      if (prevNode) {\n        prevNode.nextSibling = newObject;\n      }\n\n      if (parentNode && parentNode.firstChild === referenceObject) {\n        parentNode.firstChild = newObject;\n      }\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object after the reference object.\n     * `newObject` is now the next sibling of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method insertAfter\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var nextNode = this._node(referenceNode.nextSibling);\n\n      var newNode = this._node(newObject);\n\n      var parentNode = this._node(referenceNode.parent);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      newNode.parent = referenceNode.parent;\n      newNode.previousSibling = referenceObject;\n      newNode.nextSibling = referenceNode.nextSibling;\n      referenceNode.nextSibling = newObject;\n\n      if (nextNode) {\n        nextNode.previousSibling = newObject;\n      }\n\n      if (parentNode && parentNode.lastChild === referenceObject) {\n        parentNode.lastChild = newObject;\n      }\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object as the first child of the given reference object.\n     * `newObject` is now the first child of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method prependChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var newNode = this._node(newObject);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      if (referenceNode.hasChildren) {\n        this.insertBefore(referenceNode.firstChild, newObject);\n      } else {\n        newNode.parent = referenceObject;\n        referenceNode.firstChild = newObject;\n        referenceNode.lastChild = newObject;\n        referenceNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object as the last child of the given reference object.\n     * `newObject` is now the last child of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method appendChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var newNode = this._node(newObject);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      if (referenceNode.hasChildren) {\n        this.insertAfter(referenceNode.lastChild, newObject);\n      } else {\n        newNode.parent = referenceObject;\n        referenceNode.firstChild = newObject;\n        referenceNode.lastChild = newObject;\n        referenceNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n  }]);\n\n  return SymbolTree;\n}();\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/symbol-tree/lib/SymbolTree.js"],"names":["SymbolTreeNode","require","TreePosition","TreeIterator","returnTrue","reverseArrayIndex","array","reverseIndex","length","SymbolTree","description","symbol","Symbol","object","_node","node","hasChildren","firstChild","lastChild","previousSibling","nextSibling","parent","current","options","treeRoot","root","lastInclusiveDescendant","skipChildren","filter","thisArg","undefined","parentNode","index","setCachedIndex","call","push","ancestor","following","reverse","PREV","NEXT","PARENT","PRECEDING","FOLLOWING","child","childNode","currentIndex","getCachedIndex","childIndexCachedUpTo","cachedUpToNode","left","right","leftAncestors","leftAncestor","CONTAINS","rightAncestors","rightAncestor","CONTAINED_BY","DISCONNECTED","commonAncestorIndex","ancestorsMinLength","Math","min","i","leftIndex","rightIndex","removeObject","removeNode","prevNode","nextNode","cachedIndex","cachedIndexVersion","NaN","childrenChanged","referenceObject","newObject","referenceNode","newNode","isAttached","Error","insertBefore","insertAfter","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nconst SymbolTreeNode = require('./SymbolTreeNode');\nconst TreePosition = require('./TreePosition');\nconst TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n        return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n        return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n\n        /**\n         * @constructor\n         * @alias module:symbol-tree\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\n         */\n        constructor(description) {\n                this.symbol = Symbol(description || 'SymbolTree data');\n        }\n\n        /**\n         * You can use this function to (optionally) initialize an object right after its creation,\n         * to take advantage of V8's fast properties. Also useful if you would like to\n         * freeze your object.\n         *\n         * `O(1)`\n         *\n         * @method\n         * @alias module:symbol-tree#initialize\n         * @param {Object} object\n         * @return {Object} object\n         */\n        initialize(object) {\n                this._node(object);\n\n                return object;\n        }\n\n        _node(object) {\n                if (!object) {\n                        return null;\n                }\n\n                const node = object[this.symbol];\n\n                if (node) {\n                        return node;\n                }\n\n                return (object[this.symbol] = new SymbolTreeNode());\n        }\n\n        /**\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\n         *\n         * * `O(1)`\n         *\n         * @method hasChildren\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Boolean}\n         */\n        hasChildren(object) {\n                return this._node(object).hasChildren;\n        }\n\n        /**\n         * Returns the first child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method firstChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        firstChild(object) {\n                return this._node(object).firstChild;\n        }\n\n        /**\n         * Returns the last child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method lastChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastChild(object) {\n                return this._node(object).lastChild;\n        }\n\n        /**\n         * Returns the previous sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method previousSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        previousSibling(object) {\n                return this._node(object).previousSibling;\n        }\n\n        /**\n         * Returns the next sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method nextSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        nextSibling(object) {\n                return this._node(object).nextSibling;\n        }\n\n        /**\n         * Return the parent of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method parent\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        parent(object) {\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the inclusive descendant that is last in tree order of the given object.\n         *\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n         *\n         * @method lastInclusiveDescendant\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastInclusiveDescendant(object) {\n                let lastChild;\n                let current = object;\n\n                while ((lastChild = this._node(current).lastChild)) {\n                        current = lastChild;\n                }\n\n                return current;\n        }\n\n        /**\n         * Find the preceding object (A) of the given object (B).\n         * An object A is preceding an object B if A and B are in the same tree\n         * and A comes before B in tree order.\n         *\n         * * `O(n)` (worst case)\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method preceding\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @return {?Object}\n         */\n        preceding(object, options) {\n                const treeRoot = options && options.root;\n\n                if (object === treeRoot) {\n                        return null;\n                }\n\n                const previousSibling = this._node(object).previousSibling;\n\n                if (previousSibling) {\n                        return this.lastInclusiveDescendant(previousSibling);\n                }\n\n                // if there is no previous sibling return the parent (might be null)\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the following object (A) of the given object (B).\n         * An object A is following an object B if A and B are in the same tree\n         * and A comes after B in tree order.\n         *\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method following\n         * @memberOf module:symbol-tree#\n         * @param {!Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n         * @return {?Object}\n         */\n        following(object, options) {\n                const treeRoot = options && options.root;\n                const skipChildren = options && options.skipChildren;\n\n                const firstChild = !skipChildren && this._node(object).firstChild;\n\n                if (firstChild) {\n                        return firstChild;\n                }\n\n                let current = object;\n\n                do {\n                        if (current === treeRoot) {\n                                return null;\n                        }\n\n                        const nextSibling = this._node(current).nextSibling;\n\n                        if (nextSibling) {\n                                return nextSibling;\n                        }\n\n                        current = this._node(current).parent;\n                } while (current);\n\n                return null;\n        }\n\n        /**\n         * Append all children of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of children of the given `parent`\n         *\n         * @method childrenToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        childrenToArray(parent, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                const parentNode = this._node(parent);\n                let object = parentNode.firstChild;\n                let index = 0;\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, index);\n\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n\n                        object = node.nextSibling;\n                        ++index;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all inclusive ancestors of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\n         *\n         * @method ancestorsToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        ancestorsToArray(object, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let ancestor = object;\n\n                while (ancestor) {\n                        if (filter.call(thisArg, ancestor)) {\n                                array.push(ancestor);\n                        }\n                        ancestor = this._node(ancestor).parent;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all descendants of the given object to an array (in tree order).\n         *\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n         *\n         * @method treeToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        treeToArray(root, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let object = root;\n\n                while (object) {\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n                        object = this.following(object, {root: root});\n                }\n\n                return array;\n        }\n\n        /**\n         * Iterate over all children of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method childrenIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        childrenIterator(parent, options) {\n                const reverse = options && options.reverse;\n                const parentNode = this._node(parent);\n\n                return new TreeIterator(\n                        this,\n                        parent,\n                        reverse ? parentNode.lastChild : parentNode.firstChild,\n                        reverse ? TreeIterator.PREV : TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method previousSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        previousSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).previousSibling,\n                        TreeIterator.PREV\n                );\n        }\n\n        /**\n         * Iterate over all the next siblings of the given object. (in tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method nextSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        nextSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).nextSibling,\n                        TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all inclusive ancestors of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method ancestorsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        ancestorsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        object,\n                        TreeIterator.PARENT\n                );\n        }\n\n        /**\n         * Iterate over all descendants of the given object (in tree order).\n         *\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\n         *\n         * * `O(n)` (worst case for a single iteration)\n         * * `O(n)` (amortized, when completing the iterator)\n         *\n         * @method treeIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} options\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        treeIterator(root, options) {\n                const reverse = options && options.reverse;\n\n                return new TreeIterator(\n                        this,\n                        root,\n                        reverse ? this.lastInclusiveDescendant(root) : root,\n                        reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING\n                );\n        }\n\n        /**\n         * Find the index of the given object (the number of preceding siblings).\n         *\n         * * `O(n)` where `n` is the amount of preceding siblings\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method index\n         * @memberOf module:symbol-tree#\n         * @param {Object} child\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n         */\n        index(child) {\n                const childNode = this._node(child);\n                const parentNode = this._node(childNode.parent);\n\n                if (!parentNode) {\n                        // In principal, you could also find out the number of preceding siblings\n                        // for objects that do not have a parent. This method limits itself only to\n                        // objects that have a parent because that lets us optimize more.\n                        return -1;\n                }\n\n                let currentIndex = childNode.getCachedIndex(parentNode);\n\n                if (currentIndex >= 0) {\n                        return currentIndex;\n                }\n\n                currentIndex = 0;\n                let object = parentNode.firstChild;\n\n                if (parentNode.childIndexCachedUpTo) {\n                        const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n                        object = cachedUpToNode.nextSibling;\n                        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n                }\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, currentIndex);\n\n                        if (object === child) {\n                                break;\n                        }\n\n                        ++currentIndex;\n                        object = node.nextSibling;\n                }\n\n                parentNode.childIndexCachedUpTo = child;\n\n                return currentIndex;\n        }\n\n        /**\n         * Calculate the number of children.\n         *\n         * * `O(n)` where `n` is the amount of children\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method childrenCount\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @return {Number}\n         */\n        childrenCount(parent) {\n                const parentNode = this._node(parent);\n\n                if (!parentNode.lastChild) {\n                        return 0;\n                }\n\n                return this.index(parentNode.lastChild) + 1;\n        }\n\n        /**\n         * Compare the position of an object relative to another object. A bit set is returned:\n         *\n         * <ul>\n         *     <li>DISCONNECTED : 1</li>\n         *     <li>PRECEDING : 2</li>\n         *     <li>FOLLOWING : 4</li>\n         *     <li>CONTAINS : 8</li>\n         *     <li>CONTAINED_BY : 16</li>\n         * </ul>\n         *\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n         * DISCONNECTED never occurs with any other bit.\n         *\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n         *\n         * * `O(n + m + o)` (worst case)\n         * * `O(n + m)` (amortized, if the tree is not modified)\n         *\n         * @method compareTreePosition\n         * @memberOf module:symbol-tree#\n         * @param {Object} left\n         * @param {Object} right\n         * @return {Number}\n         */\n        compareTreePosition(left, right) {\n                // In DOM terms:\n                // left = reference / context object\n                // right = other\n\n                if (left === right) {\n                        return 0;\n                }\n\n                /* jshint -W016 */\n\n                const leftAncestors = []; { // inclusive\n                        let leftAncestor = left;\n\n                        while (leftAncestor) {\n                                if (leftAncestor === right) {\n                                        return TreePosition.CONTAINS | TreePosition.PRECEDING;\n                                        // other is ancestor of reference\n                                }\n\n                                leftAncestors.push(leftAncestor);\n                                leftAncestor = this.parent(leftAncestor);\n                        }\n                }\n\n\n                const rightAncestors = []; {\n                        let rightAncestor = right;\n\n                        while (rightAncestor) {\n                                if (rightAncestor === left) {\n                                        return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n                                }\n\n                                rightAncestors.push(rightAncestor);\n                                rightAncestor = this.parent(rightAncestor);\n                        }\n                }\n\n\n                const root = reverseArrayIndex(leftAncestors, 0);\n\n                if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n                        // note: unlike DOM, preceding / following is not set here\n                        return TreePosition.DISCONNECTED;\n                }\n\n                // find the lowest common ancestor\n                let commonAncestorIndex = 0;\n                const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n                for (let i = 0; i < ancestorsMinLength; ++i) {\n                        const leftAncestor  = reverseArrayIndex(leftAncestors, i);\n                        const rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n                        if (leftAncestor !== rightAncestor) {\n                                break;\n                        }\n\n                        commonAncestorIndex = i;\n                }\n\n                // indexes within the common ancestor\n                const leftIndex  = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n                const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n\n                return rightIndex < leftIndex\n                        ? TreePosition.PRECEDING\n                        : TreePosition.FOLLOWING;\n        }\n\n        /**\n         * Remove the object from this tree.\n         * Has no effect if already removed.\n         *\n         * * `O(1)`\n         *\n         * @method remove\n         * @memberOf module:symbol-tree#\n         * @param {Object} removeObject\n         * @return {Object} removeObject\n         */\n        remove(removeObject) {\n                const removeNode = this._node(removeObject);\n                const parentNode = this._node(removeNode.parent);\n                const prevNode = this._node(removeNode.previousSibling);\n                const nextNode = this._node(removeNode.nextSibling);\n\n                if (parentNode) {\n                        if (parentNode.firstChild === removeObject) {\n                                parentNode.firstChild = removeNode.nextSibling;\n                        }\n\n                        if (parentNode.lastChild === removeObject) {\n                                parentNode.lastChild = removeNode.previousSibling;\n                        }\n                }\n\n                if (prevNode) {\n                        prevNode.nextSibling = removeNode.nextSibling;\n                }\n\n                if (nextNode) {\n                        nextNode.previousSibling = removeNode.previousSibling;\n                }\n\n                removeNode.parent = null;\n                removeNode.previousSibling = null;\n                removeNode.nextSibling = null;\n                removeNode.cachedIndex = -1;\n                removeNode.cachedIndexVersion = NaN;\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return removeObject;\n        }\n\n        /**\n         * Insert the given object before the reference object.\n         * `newObject` is now the previous sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertBefore\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertBefore(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const prevNode = this._node(referenceNode.previousSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceNode.previousSibling;\n                newNode.nextSibling = referenceObject;\n                referenceNode.previousSibling = newObject;\n\n                if (prevNode) {\n                        prevNode.nextSibling = newObject;\n                }\n\n                if (parentNode && parentNode.firstChild === referenceObject) {\n                        parentNode.firstChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object after the reference object.\n         * `newObject` is now the next sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertAfter\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertAfter(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const nextNode = this._node(referenceNode.nextSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceObject;\n                newNode.nextSibling = referenceNode.nextSibling;\n                referenceNode.nextSibling = newObject;\n\n                if (nextNode) {\n                        nextNode.previousSibling = newObject;\n                }\n\n                if (parentNode && parentNode.lastChild === referenceObject) {\n                        parentNode.lastChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the first child of the given reference object.\n         * `newObject` is now the first child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method prependChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        prependChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertBefore(referenceNode.firstChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the last child of the given reference object.\n         * `newObject` is now the last child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method appendChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        appendChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertAfter(referenceNode.lastChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n}\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;\n"]},"metadata":{},"sourceType":"script"}