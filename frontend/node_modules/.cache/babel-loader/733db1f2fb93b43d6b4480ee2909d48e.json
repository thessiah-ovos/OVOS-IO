{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar whatwgURL = require(\"whatwg-url\");\n\nvar HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\n\nvar PopStateEvent = require(\"../generated/PopStateEvent.js\");\n\nvar notImplemented = require(\"../../browser/not-implemented.js\");\n\nvar idlUtils = require(\"../generated/utils.js\"); // https://html.spec.whatwg.org/#session-history\n\n\nvar SessionHistory = /*#__PURE__*/function () {\n  function SessionHistory(initialEntry, window) {\n    _classCallCheck(this, SessionHistory);\n\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _createClass(SessionHistory, [{\n    key: \"_queueHistoryTraversalTask\",\n    value: function _queueHistoryTraversalTask(fn) {\n      var _this = this;\n\n      var timeoutId = this._window.setTimeout(function () {\n        _this._historyTraversalQueue.delete(timeoutId);\n\n        fn();\n      }, 0);\n\n      this._historyTraversalQueue.add(timeoutId);\n    }\n  }, {\n    key: \"clearHistoryTraversalTasks\",\n    value: function clearHistoryTraversalTasks() {\n      var _iterator = _createForOfIteratorHelper(this._historyTraversalQueue),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var timeoutId = _step.value;\n\n          this._window.clearTimeout(timeoutId);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._historyTraversalQueue.clear();\n    }\n  }, {\n    key: \"removeAllEntriesAfterCurrentEntry\",\n    // https://html.spec.whatwg.org/#dom-history-pushstate\n    value: function removeAllEntriesAfterCurrentEntry() {\n      this._entries.splice(this._currentIndex + 1, Infinity);\n    } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n\n  }, {\n    key: \"traverseByDelta\",\n    value: function traverseByDelta(delta) {\n      var _this2 = this;\n\n      this._queueHistoryTraversalTask(function () {\n        var newIndex = _this2._currentIndex + delta;\n\n        if (newIndex < 0 || newIndex >= _this2.length) {\n          return;\n        }\n\n        var specifiedEntry = _this2._entries[newIndex]; // Not implemented: unload a document guard\n        // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n        // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n\n        _this2._queueHistoryTraversalTask(function () {\n          // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n          // then cancel that attempt to navigate the browsing context.\n          // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n          // is because these navigations should already count as having \"matured\" because the document is not changing.\n          // this.clearHistoryTraversalTasks();\n          if (specifiedEntry.document !== _this2.currentEntry.document) {\n            // TODO: unload the active document with the recycle parameter set to false\n            notImplemented(\"Traversing history in a way that would change the window\", _this2._window);\n          }\n\n          _this2.traverseHistory(specifiedEntry);\n        });\n      });\n    } // https://html.spec.whatwg.org/#traverse-the-history\n\n  }, {\n    key: \"traverseHistory\",\n    value: function traverseHistory(specifiedEntry) {\n      var _this3 = this;\n\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!specifiedEntry.document) {\n        // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n        // to perform an entry update of entry, and abort these steps\n        notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n      } // Not spec compliant, just minimal. Lots of missing steps.\n\n\n      var nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n      var document = idlUtils.implForWrapper(this._window._document);\n      var currentEntry = this.currentEntry; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n      // to the value returned by the document.title IDL attribute.\n\n      if (currentEntry.title === undefined) {\n        currentEntry.title = document.title;\n      }\n\n      if (specifiedEntry.document !== currentEntry.document) {\n        // If entry has a different Document object than the current entry, then...\n        notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n      }\n\n      document._URL = specifiedEntry.url;\n      var hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n      var oldURL;\n      var newURL;\n\n      if (hashChanged) {\n        oldURL = currentEntry.url;\n        newURL = specifiedEntry.url;\n      }\n\n      if (flags.replacement) {\n        // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n        // specified entry in the session history.\n        this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n      }\n\n      this.updateCurrentEntry(specifiedEntry);\n      var state = specifiedEntry.stateObject; // TODO structured clone\n      // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n      // but the spec gives them to \"History\" and \"Document\" respecively.\n\n      document._history._state = state;\n      var stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n      specifiedEntry.document._latestEntry = specifiedEntry;\n\n      var fireEvents = function fireEvents() {\n        return _this3._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n      };\n\n      if (nonBlockingEvents) {\n        this._window.setTimeout(fireEvents, 0);\n      } else {\n        fireEvents();\n      }\n    }\n  }, {\n    key: \"_fireEvents\",\n    value: function _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n      if (stateChanged) {\n        this._windowImpl._dispatch(PopStateEvent.createImpl([\"popstate\", {\n          bubbles: false,\n          state: state\n        }], {\n          isTrusted: true\n        }));\n      }\n\n      if (hashChanged) {\n        this._windowImpl._dispatch(HashChangeEvent.createImpl([\"hashchange\", {\n          bubbles: false,\n          oldURL: whatwgURL.serializeURL(oldURL),\n          newURL: whatwgURL.serializeURL(newURL)\n        }], {\n          isTrusted: true\n        }));\n      }\n    }\n  }, {\n    key: \"addEntryAfterCurrentEntry\",\n    value: function addEntryAfterCurrentEntry(entry) {\n      this._entries.splice(this._currentIndex + 1, 0, entry);\n    }\n  }, {\n    key: \"updateCurrentEntry\",\n    value: function updateCurrentEntry(entry) {\n      this._currentIndex = this._entries.indexOf(entry);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._entries.length;\n    }\n  }, {\n    key: \"currentEntry\",\n    get: function get() {\n      return this._entries[this._currentIndex];\n    }\n  }]);\n\n  return SessionHistory;\n}();\n\nmodule.exports = SessionHistory;","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","SessionHistory","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","fn","timeoutId","setTimeout","delete","add","clearTimeout","clear","splice","Infinity","delta","_queueHistoryTraversalTask","newIndex","length","specifiedEntry","document","currentEntry","traverseHistory","flags","nonBlockingEvents","Boolean","_document","title","undefined","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","_dispatch","createImpl","bubbles","isTrusted","serializeURL","entry","module","exports"],"mappings":"AAAA;;;;;;;;AACA,IAAMA,SAAS,GAAGC,OAAO,CAAC,YAAD,CAAzB;;AACA,IAAMC,eAAe,GAAGD,OAAO,CAAC,iCAAD,CAA/B;;AACA,IAAME,aAAa,GAAGF,OAAO,CAAC,+BAAD,CAA7B;;AACA,IAAMG,cAAc,GAAGH,OAAO,CAAC,kCAAD,CAA9B;;AACA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,uBAAD,CAAxB,C,CAEA;;;IACMK,c;AACJ,0BAAYC,YAAZ,EAA0BC,MAA1B,EAAkC;AAAA;;AAChC,SAAKC,OAAL,GAAeD,MAAf;AACA,SAAKE,WAAL,GAAmBL,QAAQ,CAACM,cAAT,CAAwBH,MAAxB,CAAnB;AACA,SAAKI,sBAAL,GAA8B,IAAIC,GAAJ,EAA9B;AACA,SAAKC,QAAL,GAAgB,CAACP,YAAD,CAAhB;AACA,SAAKQ,aAAL,GAAqB,CAArB;AACD;;;;+CAE0BC,E,EAAI;AAAA;;AAC7B,UAAMC,SAAS,GAAG,KAAKR,OAAL,CAAaS,UAAb,CAAwB,YAAM;AAC9C,QAAA,KAAI,CAACN,sBAAL,CAA4BO,MAA5B,CAAmCF,SAAnC;;AACAD,QAAAA,EAAE;AACH,OAHiB,EAGf,CAHe,CAAlB;;AAKA,WAAKJ,sBAAL,CAA4BQ,GAA5B,CAAgCH,SAAhC;AACD;;;iDAE4B;AAAA,iDACH,KAAKL,sBADF;AAAA;;AAAA;AAC3B,4DAAqD;AAAA,cAA1CK,SAA0C;;AACnD,eAAKR,OAAL,CAAaY,YAAb,CAA0BJ,SAA1B;AACD;AAH0B;AAAA;AAAA;AAAA;AAAA;;AAI3B,WAAKL,sBAAL,CAA4BU,KAA5B;AACD;;;AAUD;wDACoC;AAClC,WAAKR,QAAL,CAAcS,MAAd,CAAqB,KAAKR,aAAL,GAAqB,CAA1C,EAA6CS,QAA7C;AACD,K,CAED;;;;oCACgBC,K,EAAO;AAAA;;AACrB,WAAKC,0BAAL,CAAgC,YAAM;AACpC,YAAMC,QAAQ,GAAG,MAAI,CAACZ,aAAL,GAAqBU,KAAtC;;AACA,YAAIE,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,IAAI,MAAI,CAACC,MAArC,EAA6C;AAC3C;AACD;;AAED,YAAMC,cAAc,GAAG,MAAI,CAACf,QAAL,CAAca,QAAd,CAAvB,CANoC,CAQpC;AAEA;AACA;;AACA,QAAA,MAAI,CAACD,0BAAL,CAAgC,YAAM;AACpC;AACA;AAEA;AACA;AAEA;AAEA,cAAIG,cAAc,CAACC,QAAf,KAA4B,MAAI,CAACC,YAAL,CAAkBD,QAAlD,EAA4D;AAC1D;AACA1B,YAAAA,cAAc,CAAC,0DAAD,EAA6D,MAAI,CAACK,OAAlE,CAAd;AACD;;AACD,UAAA,MAAI,CAACuB,eAAL,CAAqBH,cAArB;AACD,SAdD;AAeD,OA3BD;AA4BD,K,CAED;;;;oCACgBA,c,EAA4B;AAAA;;AAAA,UAAZI,KAAY,uEAAJ,EAAI;;AAC1C,UAAI,CAACJ,cAAc,CAACC,QAApB,EAA8B;AAC5B;AACA;AACA1B,QAAAA,cAAc,CAAC,2EAAD,EAA8E,KAAKK,OAAnF,CAAd;AACD,OALyC,CAM1C;;;AAEA,UAAMyB,iBAAiB,GAAGC,OAAO,CAACF,KAAK,CAACC,iBAAP,CAAjC;AAEA,UAAMJ,QAAQ,GAAGzB,QAAQ,CAACM,cAAT,CAAwB,KAAKF,OAAL,CAAa2B,SAArC,CAAjB;AAV0C,UAYlCL,YAZkC,GAYjB,IAZiB,CAYlCA,YAZkC,EAc1C;AACA;;AACA,UAAIA,YAAY,CAACM,KAAb,KAAuBC,SAA3B,EAAsC;AACpCP,QAAAA,YAAY,CAACM,KAAb,GAAqBP,QAAQ,CAACO,KAA9B;AACD;;AAGD,UAAIR,cAAc,CAACC,QAAf,KAA4BC,YAAY,CAACD,QAA7C,EAAuD;AACrD;AACA1B,QAAAA,cAAc,CAAC,8DAAD,EAAiE,KAAKK,OAAtE,CAAd;AACD;;AAEDqB,MAAAA,QAAQ,CAACS,IAAT,GAAgBV,cAAc,CAACW,GAA/B;AAEA,UAAMC,WAAW,GACfZ,cAAc,CAACW,GAAf,CAAmBE,QAAnB,KAAgCX,YAAY,CAACS,GAAb,CAAiBE,QAAjD,IAA6Db,cAAc,CAACC,QAAf,KAA4BC,YAAY,CAACD,QADxG;AAEA,UAAIa,MAAJ;AACA,UAAIC,MAAJ;;AACA,UAAIH,WAAJ,EAAiB;AACfE,QAAAA,MAAM,GAAGZ,YAAY,CAACS,GAAtB;AACAI,QAAAA,MAAM,GAAGf,cAAc,CAACW,GAAxB;AACD;;AAED,UAAIP,KAAK,CAACY,WAAV,EAAuB;AACrB;AACA;AACA,aAAK/B,QAAL,CAAcS,MAAd,CAAqB,KAAKT,QAAL,CAAcgC,OAAd,CAAsBjB,cAAtB,IAAwC,CAA7D,EAAgE,CAAhE;AACD;;AAED,WAAKkB,kBAAL,CAAwBlB,cAAxB;AAEA,UAAMmB,KAAK,GAAGnB,cAAc,CAACoB,WAA7B,CA7C0C,CA6CA;AAE1C;AACA;;AACAnB,MAAAA,QAAQ,CAACoB,QAAT,CAAkBC,MAAlB,GAA2BH,KAA3B;AACA,UAAMI,YAAY,GAAGvB,cAAc,CAACC,QAAf,CAAwBuB,YAAxB,KAAyCxB,cAA9D;AACAA,MAAAA,cAAc,CAACC,QAAf,CAAwBuB,YAAxB,GAAuCxB,cAAvC;;AAEA,UAAMyB,UAAU,GAAG,SAAbA,UAAa;AAAA,eAAM,MAAI,CAACC,WAAL,CAAiBH,YAAjB,EAA+BX,WAA/B,EAA4CO,KAA5C,EAAmDL,MAAnD,EAA2DC,MAA3D,CAAN;AAAA,OAAnB;;AAEA,UAAIV,iBAAJ,EAAuB;AACrB,aAAKzB,OAAL,CAAaS,UAAb,CAAwBoC,UAAxB,EAAoC,CAApC;AACD,OAFD,MAEO;AACLA,QAAAA,UAAU;AACX;AACF;;;gCAEWF,Y,EAAcX,W,EAAaO,K,EAAOL,M,EAAQC,M,EAAQ;AAC5D,UAAIQ,YAAJ,EAAkB;AAChB,aAAK1C,WAAL,CAAiB8C,SAAjB,CAA2BrD,aAAa,CAACsD,UAAd,CAAyB,CAClD,UADkD,EAElD;AACEC,UAAAA,OAAO,EAAE,KADX;AAEEV,UAAAA,KAAK,EAALA;AAFF,SAFkD,CAAzB,EAMxB;AACDW,UAAAA,SAAS,EAAE;AADV,SANwB,CAA3B;AASD;;AAED,UAAIlB,WAAJ,EAAiB;AACf,aAAK/B,WAAL,CAAiB8C,SAAjB,CAA2BtD,eAAe,CAACuD,UAAhB,CAA2B,CACpD,YADoD,EAEpD;AACEC,UAAAA,OAAO,EAAE,KADX;AAEEf,UAAAA,MAAM,EAAE3C,SAAS,CAAC4D,YAAV,CAAuBjB,MAAvB,CAFV;AAGEC,UAAAA,MAAM,EAAE5C,SAAS,CAAC4D,YAAV,CAAuBhB,MAAvB;AAHV,SAFoD,CAA3B,EAOxB;AACDe,UAAAA,SAAS,EAAE;AADV,SAPwB,CAA3B;AAUD;AACF;;;8CAEyBE,K,EAAO;AAC/B,WAAK/C,QAAL,CAAcS,MAAd,CAAqB,KAAKR,aAAL,GAAqB,CAA1C,EAA6C,CAA7C,EAAgD8C,KAAhD;AACD;;;uCAEkBA,K,EAAO;AACxB,WAAK9C,aAAL,GAAqB,KAAKD,QAAL,CAAcgC,OAAd,CAAsBe,KAAtB,CAArB;AACD;;;wBA7IY;AACX,aAAO,KAAK/C,QAAL,CAAcc,MAArB;AACD;;;wBAEkB;AACjB,aAAO,KAAKd,QAAL,CAAc,KAAKC,aAAnB,CAAP;AACD;;;;;;AAyIH+C,MAAM,CAACC,OAAP,GAAiBzD,cAAjB","sourcesContent":["\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n    const document = idlUtils.implForWrapper(this._window._document);\n\n    const { currentEntry } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n\n    const hashChanged =\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\n        \"popstate\",\n        {\n          bubbles: false,\n          state\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\n        \"hashchange\",\n        {\n          bubbles: false,\n          oldURL: whatwgURL.serializeURL(oldURL),\n          newURL: whatwgURL.serializeURL(newURL)\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;\n"]},"metadata":{},"sourceType":"script"}