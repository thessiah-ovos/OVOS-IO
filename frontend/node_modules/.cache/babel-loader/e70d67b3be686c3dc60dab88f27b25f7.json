{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DOMException = require(\"domexception\");\n\nvar reportException = require(\"../helpers/runtime-script-errors\");\n\nvar _require = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar Event = require(\"../generated/Event\").interface;\n\nvar EventTargetImpl = /*#__PURE__*/function () {\n  function EventTargetImpl() {\n    _classCallCheck(this, EventTargetImpl);\n\n    this._eventListeners = Object.create(null);\n  }\n\n  _createClass(EventTargetImpl, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback, options) {\n      // webidl2js currently can't handle neither optional arguments nor callback interfaces\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n      if (callback === null) {\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        this._eventListeners[type] = [];\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.options.capture === options.capture && listener.callback === callback) {\n          return;\n        }\n      }\n\n      this._eventListeners[type].push({\n        callback: callback,\n        options: options\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback, options) {\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n      if (callback === null) {\n        // Optimization, not in the spec.\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        return;\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.callback === callback && listener.options.capture === options.capture) {\n          this._eventListeners[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventImpl) {\n      if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n        throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n      }\n\n      if (eventImpl.eventPhase !== Event.NONE) {\n        throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n      }\n\n      eventImpl.isTrusted = false;\n      return this._dispatch(eventImpl);\n    }\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(eventImpl, targetOverride) {\n      eventImpl._dispatchFlag = true;\n      eventImpl.target = targetOverride || this;\n      var eventPath = [];\n      var target = eventImpl.target;\n      var targetParent = domSymbolTree.parent(target);\n\n      while (targetParent) {\n        eventPath.push(targetParent);\n        target = targetParent;\n        targetParent = domSymbolTree.parent(targetParent);\n      }\n\n      if (eventImpl.type !== \"load\" && target._defaultView) {\n        // https://html.spec.whatwg.org/#events-and-the-window-object\n        eventPath.push(idlUtils.implForWrapper(target._defaultView));\n      }\n\n      eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n      for (var i = eventPath.length - 1; i >= 0; --i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        var object = eventPath[i];\n        var objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n\n        var eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n\n      eventImpl.eventPhase = Event.AT_TARGET;\n\n      if (!eventImpl._stopPropagationFlag) {\n        if (this._eventListeners[eventImpl.type]) {\n          var _eventListeners = this._eventListeners[eventImpl.type];\n          invokeEventListeners(_eventListeners, eventImpl.target, eventImpl);\n        }\n      }\n\n      if (eventImpl.bubbles) {\n        eventImpl.eventPhase = Event.BUBBLING_PHASE;\n\n        for (var _i = 0; _i < eventPath.length; ++_i) {\n          if (eventImpl._stopPropagationFlag) {\n            break;\n          }\n\n          var _object = eventPath[_i];\n\n          var _objectImpl = idlUtils.implForWrapper(_object) || _object; // window :(\n\n\n          var _eventListeners2 = _objectImpl._eventListeners[eventImpl.type];\n          invokeEventListeners(_eventListeners2, _object, eventImpl);\n        }\n      }\n\n      eventImpl._dispatchFlag = false;\n      eventImpl._stopPropagationFlag = false;\n      eventImpl._stopImmediatePropagationFlag = false;\n      eventImpl.eventPhase = Event.NONE;\n      eventImpl.currentTarget = null;\n      return !eventImpl._canceledFlag;\n    }\n  }]);\n\n  return EventTargetImpl;\n}();\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  var wrapper = idlUtils.wrapperForImpl(target);\n  var document = target._ownerDocument || wrapper && (wrapper._document || wrapper._ownerDocument); // Will be falsy for windows that have closed\n\n  if (!document) {\n    return;\n  } // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n\n\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n\n  eventImpl.currentTarget = target;\n\n  if (!listeners) {\n    return;\n  }\n\n  var handlers = listeners.slice();\n\n  for (var i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    var listener = handlers[i];\n    var _listener$options = listener.options,\n        capture = _listener$options.capture,\n        once = _listener$options.once;\n\n    if (listeners.indexOf(listener) === -1 || eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      var window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n  }\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  var returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(function (k) {\n      return k !== \"capture\";\n    });\n  }\n\n  var _iterator = _createForOfIteratorHelper(defaultBoolKeys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      returnValue[key] = Boolean(options[key]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return returnValue;\n}","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"names":["DOMException","require","reportException","domSymbolTree","idlUtils","Event","interface","EventTargetImpl","_eventListeners","Object","create","type","callback","options","undefined","TypeError","normalizeEventHandlerOptions","i","length","listener","capture","push","splice","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","NONE","isTrusted","_dispatch","targetOverride","target","eventPath","targetParent","parent","_defaultView","implForWrapper","CAPTURING_PHASE","_stopPropagationFlag","object","objectImpl","eventListeners","invokeEventListeners","AT_TARGET","bubbles","BUBBLING_PHASE","_stopImmediatePropagationFlag","currentTarget","_canceledFlag","module","exports","implementation","listeners","wrapper","wrapperForImpl","document","_ownerDocument","_document","constructor","name","handlers","slice","once","indexOf","handleEvent","call","e","window","defaultBoolKeys","returnValue","Boolean","filter","k","key"],"mappings":"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","sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst idlUtils = require(\"../generated/utils\");\n\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n\n    const eventPath = [];\n    let { target } = eventImpl;\n    let targetParent = domSymbolTree.parent(target);\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const { capture, once/* , passive */ } = listener.options;\n\n    if (listeners.indexOf(listener) === -1 ||\n        (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n        (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n"]},"metadata":{},"sourceType":"script"}