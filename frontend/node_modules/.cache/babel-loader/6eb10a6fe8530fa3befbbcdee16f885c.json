{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse = require(\"./parser.js\");\n\nvar serialize = require(\"./serializer.js\");\n\nvar _require = require(\"./utils.js\"),\n    asciiLowercase = _require.asciiLowercase,\n    solelyContainsHTTPTokenCodePoints = _require.solelyContainsHTTPTokenCodePoints,\n    soleyContainsHTTPQuotedStringTokenCodePoints = _require.soleyContainsHTTPQuotedStringTokenCodePoints;\n\nmodule.exports = /*#__PURE__*/function () {\n  function MIMEType(string) {\n    _classCallCheck(this, MIMEType);\n\n    string = String(string);\n    var result = parse(string);\n\n    if (result === null) {\n      throw new Error(\"Could not parse MIME type string \\\"\".concat(string, \"\\\"\"));\n    }\n\n    this._type = result.type;\n    this._subtype = result.subtype;\n    this._parameters = new MIMETypeParameters(result.parameters);\n  }\n\n  _createClass(MIMEType, [{\n    key: \"toString\",\n    value: function toString() {\n      // The serialize function works on both \"MIME type records\" (i.e. the results of parse) and on this class, since\n      // this class's interface is identical.\n      return serialize(this);\n    }\n  }, {\n    key: \"isJavaScript\",\n    value: function isJavaScript() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$allowParameters = _ref.allowParameters,\n          allowParameters = _ref$allowParameters === void 0 ? false : _ref$allowParameters;\n\n      switch (this._type) {\n        case \"text\":\n          {\n            switch (this._subtype) {\n              case \"ecmascript\":\n              case \"javascript\":\n              case \"javascript1.0\":\n              case \"javascript1.1\":\n              case \"javascript1.2\":\n              case \"javascript1.3\":\n              case \"javascript1.4\":\n              case \"javascript1.5\":\n              case \"jscript\":\n              case \"livescript\":\n              case \"x-ecmascript\":\n              case \"x-javascript\":\n                {\n                  return allowParameters || this._parameters.size === 0;\n                }\n\n              default:\n                {\n                  return false;\n                }\n            }\n          }\n\n        case \"application\":\n          {\n            switch (this._subtype) {\n              case \"ecmascript\":\n              case \"javascript\":\n              case \"x-ecmascript\":\n              case \"x-javascript\":\n                {\n                  return allowParameters || this._parameters.size === 0;\n                }\n\n              default:\n                {\n                  return false;\n                }\n            }\n          }\n\n        default:\n          {\n            return false;\n          }\n      }\n    }\n  }, {\n    key: \"isXML\",\n    value: function isXML() {\n      return this._subtype === \"xml\" && (this._type === \"text\" || this._type === \"application\") || this._subtype.endsWith(\"+xml\");\n    }\n  }, {\n    key: \"isHTML\",\n    value: function isHTML() {\n      return this._subtype === \"html\" && this._type === \"text\";\n    }\n  }, {\n    key: \"essence\",\n    get: function get() {\n      return \"\".concat(this.type, \"/\").concat(this.subtype);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(value) {\n      value = asciiLowercase(String(value));\n\n      if (value.length === 0) {\n        throw new Error(\"Invalid type: must be a non-empty string\");\n      }\n\n      if (!solelyContainsHTTPTokenCodePoints(value)) {\n        throw new Error(\"Invalid type \".concat(value, \": must contain only HTTP token code points\"));\n      }\n\n      this._type = value;\n    }\n  }, {\n    key: \"subtype\",\n    get: function get() {\n      return this._subtype;\n    },\n    set: function set(value) {\n      value = asciiLowercase(String(value));\n\n      if (value.length === 0) {\n        throw new Error(\"Invalid subtype: must be a non-empty string\");\n      }\n\n      if (!solelyContainsHTTPTokenCodePoints(value)) {\n        throw new Error(\"Invalid subtype \".concat(value, \": must contain only HTTP token code points\"));\n      }\n\n      this._subtype = value;\n    }\n  }, {\n    key: \"parameters\",\n    get: function get() {\n      return this._parameters;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(string) {\n      try {\n        return new this(string);\n      } catch (e) {\n        return null;\n      }\n    }\n  }]);\n\n  return MIMEType;\n}();\n\nvar MIMETypeParameters = /*#__PURE__*/function () {\n  function MIMETypeParameters(map) {\n    _classCallCheck(this, MIMETypeParameters);\n\n    this._map = map;\n  }\n\n  _createClass(MIMETypeParameters, [{\n    key: \"get\",\n    value: function get(name) {\n      name = asciiLowercase(String(name));\n      return this._map.get(name);\n    }\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      name = asciiLowercase(String(name));\n      return this._map.has(name);\n    }\n  }, {\n    key: \"set\",\n    value: function set(name, value) {\n      name = asciiLowercase(String(name));\n      value = String(value);\n\n      if (!solelyContainsHTTPTokenCodePoints(name)) {\n        throw new Error(\"Invalid MIME type parameter name \\\"\".concat(name, \"\\\": only HTTP token code points are valid.\"));\n      }\n\n      if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {\n        throw new Error(\"Invalid MIME type parameter value \\\"\".concat(value, \"\\\": only HTTP quoted-string token code points are \") + \"valid.\");\n      }\n\n      return this._map.set(name, value);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._map.clear();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(name) {\n      name = asciiLowercase(String(name));\n      return this._map.delete(name);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callbackFn, thisArg) {\n      this._map.forEach(callbackFn, thisArg);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return this._map.keys();\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      return this._map.values();\n    }\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      return this._map.entries();\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this._map[Symbol.iterator]();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._map.size;\n    }\n  }]);\n\n  return MIMETypeParameters;\n}();","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/whatwg-mimetype/lib/mime-type.js"],"names":["parse","require","serialize","asciiLowercase","solelyContainsHTTPTokenCodePoints","soleyContainsHTTPQuotedStringTokenCodePoints","module","exports","string","String","result","Error","_type","type","_subtype","subtype","_parameters","MIMETypeParameters","parameters","allowParameters","size","endsWith","value","length","e","map","_map","name","get","has","set","clear","delete","callbackFn","thisArg","forEach","keys","values","entries","Symbol","iterator"],"mappings":"AAAA;;;;;;AACA,IAAMA,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,iBAAD,CAAzB;;eAKIA,OAAO,CAAC,YAAD,C;IAHTE,c,YAAAA,c;IACAC,iC,YAAAA,iC;IACAC,4C,YAAAA,4C;;AAGFC,MAAM,CAACC,OAAP;AACE,oBAAYC,MAAZ,EAAoB;AAAA;;AAClBA,IAAAA,MAAM,GAAGC,MAAM,CAACD,MAAD,CAAf;AACA,QAAME,MAAM,GAAGV,KAAK,CAACQ,MAAD,CAApB;;AACA,QAAIE,MAAM,KAAK,IAAf,EAAqB;AACnB,YAAM,IAAIC,KAAJ,8CAA+CH,MAA/C,QAAN;AACD;;AAED,SAAKI,KAAL,GAAaF,MAAM,CAACG,IAApB;AACA,SAAKC,QAAL,GAAgBJ,MAAM,CAACK,OAAvB;AACA,SAAKC,WAAL,GAAmB,IAAIC,kBAAJ,CAAuBP,MAAM,CAACQ,UAA9B,CAAnB;AACD;;AAXH;AAAA;AAAA,+BA+Da;AACT;AACA;AACA,aAAOhB,SAAS,CAAC,IAAD,CAAhB;AACD;AAnEH;AAAA;AAAA,mCAqEiD;AAAA,qFAAJ,EAAI;AAAA,sCAAhCiB,eAAgC;AAAA,UAAhCA,eAAgC,qCAAd,KAAc;;AAC7C,cAAQ,KAAKP,KAAb;AACE,aAAK,MAAL;AAAa;AACX,oBAAQ,KAAKE,QAAb;AACE,mBAAK,YAAL;AACA,mBAAK,YAAL;AACA,mBAAK,eAAL;AACA,mBAAK,eAAL;AACA,mBAAK,eAAL;AACA,mBAAK,eAAL;AACA,mBAAK,eAAL;AACA,mBAAK,eAAL;AACA,mBAAK,SAAL;AACA,mBAAK,YAAL;AACA,mBAAK,cAAL;AACA,mBAAK,cAAL;AAAqB;AACnB,yBAAOK,eAAe,IAAI,KAAKH,WAAL,CAAiBI,IAAjB,KAA0B,CAApD;AACD;;AACD;AAAS;AACP,yBAAO,KAAP;AACD;AAjBH;AAmBD;;AACD,aAAK,aAAL;AAAoB;AAClB,oBAAQ,KAAKN,QAAb;AACE,mBAAK,YAAL;AACA,mBAAK,YAAL;AACA,mBAAK,cAAL;AACA,mBAAK,cAAL;AAAqB;AACnB,yBAAOK,eAAe,IAAI,KAAKH,WAAL,CAAiBI,IAAjB,KAA0B,CAApD;AACD;;AACD;AAAS;AACP,yBAAO,KAAP;AACD;AATH;AAWD;;AACD;AAAS;AACP,mBAAO,KAAP;AACD;AArCH;AAuCD;AA7GH;AAAA;AAAA,4BA8GU;AACN,aAAQ,KAAKN,QAAL,KAAkB,KAAlB,KAA4B,KAAKF,KAAL,KAAe,MAAf,IAAyB,KAAKA,KAAL,KAAe,aAApE,CAAD,IACA,KAAKE,QAAL,CAAcO,QAAd,CAAuB,MAAvB,CADP;AAED;AAjHH;AAAA;AAAA,6BAkHW;AACP,aAAO,KAAKP,QAAL,KAAkB,MAAlB,IAA4B,KAAKF,KAAL,KAAe,MAAlD;AACD;AApHH;AAAA;AAAA,wBAqBgB;AACZ,uBAAU,KAAKC,IAAf,cAAuB,KAAKE,OAA5B;AACD;AAvBH;AAAA;AAAA,wBAyBa;AACT,aAAO,KAAKH,KAAZ;AACD,KA3BH;AAAA,sBA6BWU,KA7BX,EA6BkB;AACdA,MAAAA,KAAK,GAAGnB,cAAc,CAACM,MAAM,CAACa,KAAD,CAAP,CAAtB;;AAEA,UAAIA,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;AACtB,cAAM,IAAIZ,KAAJ,CAAU,0CAAV,CAAN;AACD;;AACD,UAAI,CAACP,iCAAiC,CAACkB,KAAD,CAAtC,EAA+C;AAC7C,cAAM,IAAIX,KAAJ,wBAA0BW,KAA1B,gDAAN;AACD;;AAED,WAAKV,KAAL,GAAaU,KAAb;AACD;AAxCH;AAAA;AAAA,wBA0CgB;AACZ,aAAO,KAAKR,QAAZ;AACD,KA5CH;AAAA,sBA8CcQ,KA9Cd,EA8CqB;AACjBA,MAAAA,KAAK,GAAGnB,cAAc,CAACM,MAAM,CAACa,KAAD,CAAP,CAAtB;;AAEA,UAAIA,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;AACtB,cAAM,IAAIZ,KAAJ,CAAU,6CAAV,CAAN;AACD;;AACD,UAAI,CAACP,iCAAiC,CAACkB,KAAD,CAAtC,EAA+C;AAC7C,cAAM,IAAIX,KAAJ,2BAA6BW,KAA7B,gDAAN;AACD;;AAED,WAAKR,QAAL,GAAgBQ,KAAhB;AACD;AAzDH;AAAA;AAAA,wBA2DmB;AACf,aAAO,KAAKN,WAAZ;AACD;AA7DH;AAAA;AAAA,0BAaeR,MAbf,EAauB;AACnB,UAAI;AACF,eAAO,IAAI,IAAJ,CAASA,MAAT,CAAP;AACD,OAFD,CAEE,OAAOgB,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACF;AAnBH;;AAAA;AAAA;;IAuHMP,kB;AACJ,8BAAYQ,GAAZ,EAAiB;AAAA;;AACf,SAAKC,IAAL,GAAYD,GAAZ;AACD;;;;wBAMGE,I,EAAM;AACRA,MAAAA,IAAI,GAAGxB,cAAc,CAACM,MAAM,CAACkB,IAAD,CAAP,CAArB;AACA,aAAO,KAAKD,IAAL,CAAUE,GAAV,CAAcD,IAAd,CAAP;AACD;;;wBAEGA,I,EAAM;AACRA,MAAAA,IAAI,GAAGxB,cAAc,CAACM,MAAM,CAACkB,IAAD,CAAP,CAArB;AACA,aAAO,KAAKD,IAAL,CAAUG,GAAV,CAAcF,IAAd,CAAP;AACD;;;wBAEGA,I,EAAML,K,EAAO;AACfK,MAAAA,IAAI,GAAGxB,cAAc,CAACM,MAAM,CAACkB,IAAD,CAAP,CAArB;AACAL,MAAAA,KAAK,GAAGb,MAAM,CAACa,KAAD,CAAd;;AAEA,UAAI,CAAClB,iCAAiC,CAACuB,IAAD,CAAtC,EAA8C;AAC5C,cAAM,IAAIhB,KAAJ,8CAA+CgB,IAA/C,gDAAN;AACD;;AACD,UAAI,CAACtB,4CAA4C,CAACiB,KAAD,CAAjD,EAA0D;AACxD,cAAM,IAAIX,KAAJ,CAAU,8CAAsCW,KAAtC,kEAAV,CAAN;AAED;;AAED,aAAO,KAAKI,IAAL,CAAUI,GAAV,CAAcH,IAAd,EAAoBL,KAApB,CAAP;AACD;;;4BAEO;AACN,WAAKI,IAAL,CAAUK,KAAV;AACD;;;4BAEMJ,I,EAAM;AACXA,MAAAA,IAAI,GAAGxB,cAAc,CAACM,MAAM,CAACkB,IAAD,CAAP,CAArB;AACA,aAAO,KAAKD,IAAL,CAAUM,MAAV,CAAiBL,IAAjB,CAAP;AACD;;;4BAEOM,U,EAAYC,O,EAAS;AAC3B,WAAKR,IAAL,CAAUS,OAAV,CAAkBF,UAAlB,EAA8BC,OAA9B;AACD;;;2BAEM;AACL,aAAO,KAAKR,IAAL,CAAUU,IAAV,EAAP;AACD;;;6BAEQ;AACP,aAAO,KAAKV,IAAL,CAAUW,MAAV,EAAP;AACD;;;8BAES;AACR,aAAO,KAAKX,IAAL,CAAUY,OAAV,EAAP;AACD;;SAEAC,MAAM,CAACC,Q;4BAAY;AAClB,aAAO,KAAKd,IAAL,CAAUa,MAAM,CAACC,QAAjB,GAAP;AACD;;;wBAxDU;AACT,aAAO,KAAKd,IAAL,CAAUN,IAAjB;AACD","sourcesContent":["\"use strict\";\nconst parse = require(\"./parser.js\");\nconst serialize = require(\"./serializer.js\");\nconst {\n  asciiLowercase,\n  solelyContainsHTTPTokenCodePoints,\n  soleyContainsHTTPQuotedStringTokenCodePoints\n} = require(\"./utils.js\");\n\nmodule.exports = class MIMEType {\n  constructor(string) {\n    string = String(string);\n    const result = parse(string);\n    if (result === null) {\n      throw new Error(`Could not parse MIME type string \"${string}\"`);\n    }\n\n    this._type = result.type;\n    this._subtype = result.subtype;\n    this._parameters = new MIMETypeParameters(result.parameters);\n  }\n\n  static parse(string) {\n    try {\n      return new this(string);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  get essence() {\n    return `${this.type}/${this.subtype}`;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(value) {\n    value = asciiLowercase(String(value));\n\n    if (value.length === 0) {\n      throw new Error(\"Invalid type: must be a non-empty string\");\n    }\n    if (!solelyContainsHTTPTokenCodePoints(value)) {\n      throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);\n    }\n\n    this._type = value;\n  }\n\n  get subtype() {\n    return this._subtype;\n  }\n\n  set subtype(value) {\n    value = asciiLowercase(String(value));\n\n    if (value.length === 0) {\n      throw new Error(\"Invalid subtype: must be a non-empty string\");\n    }\n    if (!solelyContainsHTTPTokenCodePoints(value)) {\n      throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);\n    }\n\n    this._subtype = value;\n  }\n\n  get parameters() {\n    return this._parameters;\n  }\n\n  toString() {\n    // The serialize function works on both \"MIME type records\" (i.e. the results of parse) and on this class, since\n    // this class's interface is identical.\n    return serialize(this);\n  }\n\n  isJavaScript({ allowParameters = false } = {}) {\n    switch (this._type) {\n      case \"text\": {\n        switch (this._subtype) {\n          case \"ecmascript\":\n          case \"javascript\":\n          case \"javascript1.0\":\n          case \"javascript1.1\":\n          case \"javascript1.2\":\n          case \"javascript1.3\":\n          case \"javascript1.4\":\n          case \"javascript1.5\":\n          case \"jscript\":\n          case \"livescript\":\n          case \"x-ecmascript\":\n          case \"x-javascript\": {\n            return allowParameters || this._parameters.size === 0;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n      case \"application\": {\n        switch (this._subtype) {\n          case \"ecmascript\":\n          case \"javascript\":\n          case \"x-ecmascript\":\n          case \"x-javascript\": {\n            return allowParameters || this._parameters.size === 0;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  isXML() {\n    return (this._subtype === \"xml\" && (this._type === \"text\" || this._type === \"application\")) ||\n           this._subtype.endsWith(\"+xml\");\n  }\n  isHTML() {\n    return this._subtype === \"html\" && this._type === \"text\";\n  }\n};\n\nclass MIMETypeParameters {\n  constructor(map) {\n    this._map = map;\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  get(name) {\n    name = asciiLowercase(String(name));\n    return this._map.get(name);\n  }\n\n  has(name) {\n    name = asciiLowercase(String(name));\n    return this._map.has(name);\n  }\n\n  set(name, value) {\n    name = asciiLowercase(String(name));\n    value = String(value);\n\n    if (!solelyContainsHTTPTokenCodePoints(name)) {\n      throw new Error(`Invalid MIME type parameter name \"${name}\": only HTTP token code points are valid.`);\n    }\n    if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {\n      throw new Error(`Invalid MIME type parameter value \"${value}\": only HTTP quoted-string token code points are ` +\n                      `valid.`);\n    }\n\n    return this._map.set(name, value);\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n  delete(name) {\n    name = asciiLowercase(String(name));\n    return this._map.delete(name);\n  }\n\n  forEach(callbackFn, thisArg) {\n    this._map.forEach(callbackFn, thisArg);\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  [Symbol.iterator]() {\n    return this._map[Symbol.iterator]();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}