{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse5 = require(\"parse5\");\n\nvar sax = require(\"sax\");\n\nvar attributes = require(\"../living/attributes\");\n\nvar DocumentType = require(\"../living/generated/DocumentType\");\n\nvar JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\n\nvar _require = require(\"../living/helpers/namespaces\"),\n    HTML_NS = _require.HTML_NS; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n\n\nvar OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\n\nvar originalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function () {\n  var before = this.items[this.stackTop];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  originalPop.apply(this, args);\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nvar originalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  originalPush.apply(this, args);\n  var after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function HTMLToDOM(parsingMode) {\n    _classCallCheck(this, HTMLToDOM);\n\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  _createClass(HTMLToDOM, [{\n    key: \"appendToNode\",\n    value: function appendToNode(html, node) {\n      html = String(html);\n      return this._doParse(html, true, node);\n    }\n  }, {\n    key: \"appendToDocument\",\n    value: function appendToDocument(html, documentImpl) {\n      html = String(html);\n      return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n    }\n  }, {\n    key: \"_doParse\",\n    value: function _doParse() {\n      return this.parser === parse5 ? this._parseWithParse5.apply(this, arguments) : this._parseWithSax.apply(this, arguments);\n    }\n  }, {\n    key: \"_parseWithParse5\",\n    value: function _parseWithParse5(html, isFragment, contextNode) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n      options.treeAdapter = adapter;\n\n      if (isFragment) {\n        var fragment = this.parser.parseFragment(contextNode, html, options);\n\n        if (contextNode._templateContents) {\n          contextNode._templateContents.appendChild(fragment);\n        } else {\n          contextNode.appendChild(fragment);\n        }\n      } else {\n        this.parser.parse(html, options);\n      }\n\n      return contextNode;\n    }\n  }, {\n    key: \"_parseWithSax\",\n    value: function _parseWithSax(html, isFragment, contextNode) {\n      var SaxParser = this.parser.parser;\n      var parser = new SaxParser(\n      /* strict = */\n      true, {\n        xmlns: true,\n        strictEntities: true\n      });\n      parser.noscript = false;\n      parser.looseCase = \"toString\";\n      var openStack = [contextNode];\n\n      parser.ontext = function (text) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"text\",\n          data: text\n        });\n      };\n\n      parser.oncdata = function (cdata) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"cdata\",\n          data: cdata\n        });\n      };\n\n      parser.onopentag = function (arg) {\n        var attrs = Object.keys(arg.attributes).map(function (key) {\n          var rawAttribute = arg.attributes[key];\n          var prefix = rawAttribute.prefix;\n          var localName = rawAttribute.local;\n\n          if (prefix === \"xmlns\" && localName === \"\") {\n            // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n            localName = prefix;\n            prefix = null;\n          }\n\n          if (prefix === \"\") {\n            prefix = null;\n          }\n\n          var namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n          return {\n            name: rawAttribute.name,\n            value: rawAttribute.value,\n            prefix: prefix,\n            localName: localName,\n            namespace: namespace\n          };\n        });\n        var tag = {\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attributes: attrs\n        };\n\n        if (arg.local === \"script\" && arg.uri === HTML_NS) {\n          openStack.push(tag);\n        } else {\n          var elem = setChildForSax(openStack[openStack.length - 1], tag);\n          openStack.push(elem);\n        }\n      };\n\n      parser.onclosetag = function () {\n        var elem = openStack.pop();\n\n        if (elem.constructor.name === \"Object\") {\n          // we have an empty script tag\n          setChildForSax(openStack[openStack.length - 1], elem);\n        }\n      };\n\n      parser.onscript = function (scriptText) {\n        var tag = openStack.pop();\n        tag.children = [{\n          type: \"text\",\n          data: scriptText\n        }];\n        var elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      };\n\n      parser.oncomment = function (comment) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"comment\",\n          data: comment\n        });\n      };\n\n      parser.onprocessinginstruction = function (pi) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"directive\",\n          name: \"?\" + pi.name,\n          data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n        });\n      };\n\n      parser.ondoctype = function (dt) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"directive\",\n          name: \"!doctype\",\n          data: \"!doctype \" + dt\n        });\n        var entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n        var result;\n\n        while (result = entityMatcher.exec(dt)) {\n          var _result = result,\n              _result2 = _slicedToArray(_result, 3),\n              name = _result2[1],\n              value = _result2[2];\n\n          if (!(name in parser.ENTITIES)) {\n            parser.ENTITIES[name] = value;\n          }\n        }\n      };\n\n      parser.onerror = function (err) {\n        throw err;\n      };\n\n      parser.write(html).close();\n    }\n  }]);\n\n  return HTMLToDOM;\n}();\n\nfunction setChildForSax(parentImpl, node) {\n  var currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n  var newNode;\n  var isTemplateContents = false;\n\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        var data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    var _iterator = _createForOfIteratorHelper(node.attributes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var a = _step.value;\n        attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (node.children) {\n    for (var c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  } // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n\n\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument: ownerDocument,\n    name: name,\n    publicId: publicId,\n    systemId: systemId\n  });\n}","map":{"version":3,"sources":["/mnt/c/Users/riche/ThessianSound/ThessianSoundLLC/frontend/node_modules/jsdom/lib/jsdom/browser/htmltodom.js"],"names":["parse5","require","sax","attributes","DocumentType","JSDOMParse5Adapter","HTML_NS","OpenElementStack","originalPop","prototype","pop","before","items","stackTop","args","apply","_poppedOffStackOfOpenElements","originalPush","push","after","_pushedOnStackOfOpenElements","module","exports","parsingMode","parser","html","node","String","_doParse","documentImpl","_parseOptions","_parseWithParse5","_parseWithSax","isFragment","contextNode","options","adapter","_ownerDocument","treeAdapter","fragment","parseFragment","_templateContents","appendChild","parse","SaxParser","xmlns","strictEntities","noscript","looseCase","openStack","ontext","text","setChildForSax","length","type","data","oncdata","cdata","onopentag","arg","attrs","Object","keys","map","key","rawAttribute","prefix","localName","local","namespace","uri","name","value","tag","elem","onclosetag","constructor","onscript","scriptText","children","oncomment","comment","onprocessinginstruction","pi","body","ondoctype","dt","entityMatcher","result","exec","ENTITIES","onerror","err","write","close","parentImpl","currentDocument","newNode","isTemplateContents","_createElementWithCorrectElementInterface","_prefix","_namespaceURI","tagName","createTextNode","createCDATASection","createComment","toLowerCase","slice","createProcessingInstruction","substring","parseDocType","a","setAttributeValue","c","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","doc","test","createDocumentTypeInternal","publicPieces","systemPieces","ownerDocument","publicId","systemId","createImpl"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\nconst { HTML_NS } = require(\"../living/helpers/namespaces\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\nconst OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\nconst originalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n  originalPop.apply(this, args);\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nconst originalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function (...args) {\n  originalPush.apply(this, args);\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports = class HTMLToDOM {\n  constructor(parsingMode) {\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  appendToNode(html, node) {\n    html = String(html);\n\n    return this._doParse(html, true, node);\n  }\n\n  appendToDocument(html, documentImpl) {\n    html = String(html);\n\n    return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n  }\n\n  _doParse(...args) {\n    return this.parser === parse5 ? this._parseWithParse5(...args) : this._parseWithSax(...args);\n  }\n\n  _parseWithParse5(html, isFragment, contextNode, options = {}) {\n    const adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n    options.treeAdapter = adapter;\n\n    if (isFragment) {\n      const fragment = this.parser.parseFragment(contextNode, html, options);\n\n      if (contextNode._templateContents) {\n        contextNode._templateContents.appendChild(fragment);\n      } else {\n        contextNode.appendChild(fragment);\n      }\n    } else {\n      this.parser.parse(html, options);\n    }\n\n    return contextNode;\n  }\n\n  _parseWithSax(html, isFragment, contextNode) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(/* strict = */true, { xmlns: true, strictEntities: true });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [contextNode];\n    parser.ontext = text => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.oncdata = cdata => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"cdata\",\n        data: cdata\n      });\n    };\n    parser.onopentag = arg => {\n      const attrs = Object.keys(arg.attributes).map(key => {\n        const rawAttribute = arg.attributes[key];\n\n        let { prefix } = rawAttribute;\n        let localName = rawAttribute.local;\n        if (prefix === \"xmlns\" && localName === \"\") {\n          // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n          localName = prefix;\n          prefix = null;\n        }\n\n        if (prefix === \"\") {\n          prefix = null;\n        }\n\n        const namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n\n        return { name: rawAttribute.name, value: rawAttribute.value, prefix, localName, namespace };\n      });\n      const tag = {\n        type: \"tag\",\n        name: arg.local,\n        prefix: arg.prefix,\n        namespace: arg.uri,\n        attributes: attrs\n      };\n\n      if (arg.local === \"script\" && arg.uri === HTML_NS) {\n        openStack.push(tag);\n      } else {\n        const elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") { // we have an empty script tag\n        setChildForSax(openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{ type: \"text\", data: scriptText }];\n      const elem = setChildForSax(openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while ((result = entityMatcher.exec(dt))) {\n        const [, name, value] = result;\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n};\n\nfunction setChildForSax(parentImpl, node) {\n  const currentDocument = (parentImpl && parentImpl._ownerDocument) || parentImpl;\n\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    for (const a of node.attributes) {\n      attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n    }\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { ownerDocument, name, publicId, systemId });\n}\n"]},"metadata":{},"sourceType":"script"}